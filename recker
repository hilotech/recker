#!/bin/bash

:<<'@@'
@NAME recker
@DESCRIPTION Docker tiny helper
@AUTHOR HiLoTECH
@URL http://www.hilotech.jp/
@DATE 2016/03/11
@@

set -e
set -u

DEBUG="${DEBUG-}"
VERBOSE="${VERBOSE-}"
[[ -n "${VERBOSE-}" ]] \
    && set -v

readonly _VERSION='0.9.20160311'
readonly _RECKER_ABS=$( readlink -f $0 )
readonly _RECKER="${_RECKER_ABS##*/}"

_DOCKER_VERSION=$( \
    _ar=( \
        $( \
            docker --version \
                | cut -d ' ' -f 3 \
                | cut -d ',' -f 1 \
                | cut --output-delimiter=' ' -d '.' -f 1- \
        ) \
    ); \
    echo $(( _ar[0]*10000+_ar[1]*100+_ar[2]*1 )) \
    )

mapfile _USAGE <<'_EOF_'
NAME
  Recker - Docker command helper

SYNOPSIS
  recker [subcommand] [options] other_arguments

DESCRIPTION
  Recker gives you short-hands for Docker's complex commands. At the same
  time it becomes a character-based-GUI interface for manipulating Docker
  images and containers. Main features are:
    * Character-based-GUI selecting function for containers/images
    * Command line auto-complete-definition for Bash
    * Scaffold function for building images
    * HTTP/SSH port auto-mapper for running containers

PREREQUISITES
  * Docker
    Version>=1.9.0
  * Percol
    Python-based CUI selection helper. https://github.com/mooz/percol
  * Bash
    Version>=4

SUBCOMMANDS
  images | images-a
    Show docker local images. Docker's too long output lines are trimmed
    suitable for your terminal width. 'images-a' works same as 'images'
    but '-a' option (show all images) will be applied.
  ps | ps-a
    Show docker containers.
  rmi | rmi-a
    Remove docker images.
  stop | stop-a
    Stop containers.
  kill | kill-a
    Kill containers.
  stop-rm | stop-rm-a
    Stop containers and remove them.
  kill-rm | kill-rm-a
    Kill containers and remove them.
  get-container-ip
    Show container's IP address.
  get-container-ports
    Show container's mapped ports.
  get-container-port-http | get-container-port-ssh
    Same as get-container-ports, but only for http or ssh.
  get-containers-names
    Show the list of running container's names.
  top
    Show running processes of a container.
  run
    Select an image/context directory and run the container.
  scaffold
    Make a context directory's scaffold for building Docker image.
  build
    Select a context directory made by 'scaffold' and build the image.
  clean
    Clean up context directory. Removes containers, volumes, etc.
  select-containers | select-containers-a
    Select containers and display its' names.
  select-images | select-images-a
    Select images and display its' names.
  bashcompletion
    Print defining script of bash completion for Recker.
    For temporarily use do like this:
        $ source <(recker bashcompletion)
  cut
    Cut off the output of Docker which spews too long lines. Suitable
    for your terminal width.
        Example:
            $ docker foo bar | recker cut
  usage | help | man
    Show this message.
  version
    Print this Recker's version.

SUPPORTED OS
  * Linux
    I tested only CentOS 6, 7...
    and on Raspbian a little.

_EOF_

# Use /etc/recker/recker.conf or ~.recker/recker.conf to override
# Shell script variable-definition format such as:
# DOCKER_ENTERING_COMMAND='/bin/zsh'
declare -A _CONF=(
    [DIR_CONF_GLOBAL]='/etc/recker'
    [DIR_CONF_USERS]='.recker'
    [FILE_CONFIG]='recker.conf'
    [DIR_DOCKER_BASE_GLOBAL]='/var/docker'
    [DIR_DOCKER_BASE_USERS]='Docker'
    [DIR_DOCKER_DOCKERFILES]='Dockerfiles'
    [DIR_DOCKER_VOLUMES]='volumes'
    [DOCKER_BUILD_OPT]='--force-rm --rm=true --no-cache=true '
    [DOCKER_BUILD_BASE_IMG]='centos:centos6'
    [DOCKER_MAINTAINER_NAME]='recker'
    [DOCKER_ENTRY_EXECUTABLE]='/bin/bash'
    [DOCKER_ENTERING_COMMAND]='/bin/bash'
    [DOCKER_SERVICE_ENTRYPOINT]='/etc/container_init.sh'
    [DOCKER_RUN_SWITCH_BG]='-dt'
    [DOCKER_RUN_SWITCH_FG]='-it --rm=true'
    [DEVICE_NET]='docker0'
    [AUTOMAP_PORT_HTTP_FROM]=8000
    [AUTOMAP_PORT_SSH_FROM]=2200
    [EXEC_DOCKER]='docker'
    [EXEC_PERCOL]='percol'
    [EXEC_IP]='ip'
    [EXEC_POSTMAP]='postmap'
    [COMMAND_PRE_RUN]=''
    [COMMAND_POST_RUN]=''
#    [POSTFIX_TRANSPORT]='/etc/postfix/transport-recker'
)

declare -r -a _SUB_COMMANDS=(
    'build' 'run' 'run-fg' 'run-bg' 'clean'
    'scaffold' 'enter'
    'implode' 'explode'
    'images' 'images-a' 'ps' 'ps-a' 'top'
    'rmi' 'rmi-a'
    'stop' 'stop-a' 'kill' 'kill-a'
    'stop-rm' 'stop-rm-a' 'rm' 'kill-rm' 'kill-rm-a'
    'stop-all-containers' 'kill-all-containers' 'rm-all-containers'
    'destroy-all-containers'
    'select-images' 'select-images-a'
    'select-containers' 'select-containers-a'
    'get-container-ip'
    'get-containers-fqdn-and-port-smtp'
    'get-container-ports' 'get-container-port-http'
    'get-container-port-ssh'
    'get-containers-names' 'get-containers-names-and-port-http'
    'usage' 'help' 'man' 'version' 'cut'
    'exec-all'
    'bashcompletion'
    'install-percol'
    '_comp'
    '_print_container_lib_sh'
)

declare -r -A _QUERIES=(
    [_DOCKER_INSPECT_PORTS]='{{range $key, $value := .HostConfig.PortBindings }}{{if $value }}{{ $key }}:{{ range $value }}{{ println .HostPort }}{{end}}{{end}}{{end}}'
    [_DOCKER_INSPECT_IP]='{{ .NetworkSettings.IPAddress }}'
)

declare -r -A _SEDEXP=(
    [GET_DOCKER_CNAME]='s|^[^[:blank:]]\{1,\}[[:blank:]].*[[:blank:]]\([^[:blank:]]\{1,\}\)[[:blank:]]\{1,\}$|\1|'
    [GET_DOCKER_CID_NAME]='s|^\([^[:blank:]]\{1,\}\)[[:blank:]].*[[:blank:]]\([^[:blank:]]\{1,\}\)[[:blank:]]\{1,\}$|\1 \2|'
)

declare -r -A _CONST=(
    [CLEANUP_UNITS_ALL]='CONTAINER IMAGE VOLUME USER DB_USER DATABASE FILE DIR'
    [CLEANUP_UNITS_PREBUILD]='CONTAINER IMAGE VOLUME USER DB_USER DATABASE FILE'
)

function _caution() {
    echo -e "\e[31m$@\e[m" >&2
}

function _mention() {
    echo -e "\e[34m$@\e[m" >&2
}

function _warn() {
    echo -e "\e[31m$@\e[m" >&2
}

function _die() {
    echo -e "\e[31m$@\e[m" >&2
    exit 1
}

function _sureYesOrNo() {
    _caution "$@ [y/n]"
    local i
    while read i
    do
        i="${i-}"
        i="${i,,}"
        if [[ "${i-}" =~ ^[yn]$ ]]; then
            echo "${i-}"
            break
        fi
    done
}

function _noExecP() {
    if which "${1-}" >& /dev/null; then
        return 1
    else
        return 0
    fi
}

function _noExecThenDie() {
    _noExecP "$1" && \
        _die "[Error] $1 not found in your PATH"
    return 0
}

function _has() {
    local _list="${1-}"
    local _elem="${2-}"
    [[ -z "${_list-}" || -z "${_elem-}" ]] \
        && return 1
    echo "${_list-}" | tr ' ' '\n' | grep -q '^'${_elem-}'$' \
        || return 1
}

# Usage: local -A __opts=`_getOptsArray --hoge=fuga --age=uge`
#        to get the value: ${__opts["hoge"]}
function _getOptsArray() {
    local __name=''
    local __value=''
    local __declaration=''
    local -A __opts
    for OPT in "$@"
    do
        __name=${OPT%%=*}
        __name=${__name#--}
        [[ -z "$__name" ]] && continue
        __value=${OPT#*=}
        __name=${__name//-/_}
        __declaration="$__declaration[\"$__name\"]=\"$__value\" "
    done

    __declaration="( $__declaration)"
    echo $__declaration
}

function _getEuid() {
    echo $(id -u)
}

function _makeSureDir() {
    [[ -d "$1" ]] && return 0
    mkdir -p "$1"
    return "$?"
}

function _initGlobal() {
    [[ $(_getEuid) -ne 0 ]] && return 1

    local _confDir=${_CONF[DIR_CONF_GLOBAL]}
    _makeSureDir $_confDir
    [[ ! -r "$_confDir/${_CONF[FILE_CONFIG]}" ]] && \
        touch "$_confDir/${_CONF[FILE_CONFIG]}"
    local _baseDir=${_CONF[DIR_DOCKER_BASE_GLOBAL]}
    _makeSureDir $_baseDir
    _makeSureDir "$_baseDir/${_CONF[DIR_DOCKER_VOLUMES]}"
    _makeSureDir "$_baseDir/${_CONF[DIR_DOCKER_DOCKERFILES]}"
}

function _initUserland() {
    [[ $(_getEuid) -eq 0 ]] && return 1

    local _confDir="$HOME/${_CONF[DIR_CONF_USERS]}"
    _makeSureDir $_confDir
    [[ ! -r "$_confDir/${_CONF[FILE_CONFIG]}" ]] && \
        touch "$_confDir/${_CONF[FILE_CONFIG]}"
    _makeSureDir "${_CONF[DIR_DOCKER_BASE_THISUSER]}"
    _makeSureDir "${_CONF[DIR_DOCKER_DOCKERFILES_THISUSER]}"
    _makeSureDir "${_CONF[DIR_DOCKER_VOLUMES_THISUSER]}"
}

function _setExecs() {
    _PERCOL=${_CONF[EXEC_PERCOL]}
    _DOCKER=${_CONF[EXEC_DOCKER]}
    _POSTMAP=${_CONF[EXEC_POSTMAP]}
}

function _isPriorDockerVersion() {
    local _dockerVersion=$( \
        $_DOCKER --version | cut -d ' ' -f 3 \
    )
    _dockerVersion=${_dockerVersion/,/}
    local _semantics=( ${_dockerVersion//./ } )
    [[ "${1-}" -ge 0 ]] && [[ "${1-}" -ge "${_semantics[0]-}" ]] || \
        return 1
    [[ "${2-}" -ge 0 ]] && [[ "${2-}" -ge "${_semantics[1]-}" ]] || \
        return 1
    [[ "${3-}" -ge 0 ]] && [[ "${3-}" -ge "${_semantics[2]-}" ]] || \
        return 1
}

function _getOSName() {
    local _result=''
    uname >& /dev/null || return 1
    _result=$( uname )
    echo "${_result-}"
}

function _getDistName() {
    # TODO: consult /etc/os-release and/or lsb_release too.
    local _name
    local i
    for i in debian fedora redhat gentoo arch SuSE
    do
        if [[ \
            -e "/etc/${i-}-release" \
            || -e "/etc/${i-}_release" \
            || -e "/etc/${i-}_version" \
        ]]; then
            _name="${i-}"
            break
        fi
    done
    [[ ! "${_name-}" ]] && return 1
    [[ "${_name-}" = 'redhat' ]] \
        && grep -q 'CentOS' /etc/redhat-release >& /dev/null \
        && _name='centos'
    [[ "${_name-}" = 'debian' ]] \
        && lsb_release -si >& /dev/null \
        && [[ "$(lsb_release -si)" = "Ubuntu" ]] \
        && _name='ubuntu'
    echo "${_name,,}"
}

function _checkEnvironment() {
    [[ ! "${BASH_VERSION-}" ]] && \
        _die '[Error] This program needs BASH'
    local bashMajorVersion=${BASH_VERSION%%.*}
    [[ $bashMajorVersion -lt 4 ]] &&  \
        _die '[Error] This program needs BASH 4.x over'
    local i
    for i in docker; # $_PERCOL
    do
        _noExecThenDie "$i"
    done
}

function _init() {
    _setExecs
    _checkEnvironment
    _initGlobal || _initUserland || :
}

function _showUsage(){
    printf %s "${_USAGE[@]}"
}

function _getHostIPv4() {
    echo $(ip route | grep "${_CONF[DEVICE_NET]}" | awk '{print $9}')
}


###
### read config files
###
_confFiles=( \
    "${_CONF[DIR_CONF_GLOBAL]}/${_CONF[FILE_CONFIG]}" \
)
[[ $(_getEuid) -eq 0 ]] \
    || _confFiles+=( "$HOME/${_CONF[DIR_CONF_USERS]}/${_CONF[FILE_CONFIG]}" )
for i in "${_confFiles[@]}"
do
    _confFile="${i-}"
    [[ -r "${_confFile-}" ]] && \
        source <( \
            grep '^[A-Z0-9_]\{1,\}=.*$' "${_confFile-}" \
            | sed -e 's|^\([A-Z0-9_]\{1,\}\)\(=.*\)$|_CONF[\1]\2|' \
        )
done

if [[ $(_getEuid) -ne 0 ]]; then
    # DIR_DOCKER_BASE_THISUSER
    _CONF[DIR_DOCKER_BASE_THISUSER]="${_CONF[DIR_DOCKER_BASE_USERS]}"
    [[ ! "${_CONF[DIR_DOCKER_BASE_THISUSER]}" =~ ^/ ]] \
        && _CONF[DIR_DOCKER_BASE_THISUSER]="$HOME/${_CONF[DIR_DOCKER_BASE_USERS]}"

    # DIR_DOCKER_DOCKERFILES_THISUSER
    _CONF[DIR_DOCKER_DOCKERFILES_THISUSER]="${_CONF[DIR_DOCKER_DOCKERFILES]}"
    [[ ! "${_CONF[DIR_DOCKER_DOCKERFILES_THISUSER]}" =~ ^/ ]] \
        && _CONF[DIR_DOCKER_DOCKERFILES_THISUSER]="${_CONF[DIR_DOCKER_BASE_THISUSER]}/${_CONF[DIR_DOCKER_DOCKERFILES_THISUSER]}"

    # DIR_DOCKER_VOLUMES_THISUSER
    _CONF[DIR_DOCKER_VOLUMES_THISUSER]="${_CONF[DIR_DOCKER_VOLUMES]}"
    [[ ! "${_CONF[DIR_DOCKER_VOLUMES_THISUSER]}" =~ ^/ ]] \
        && _CONF[DIR_DOCKER_VOLUMES_THISUSER]="${_CONF[DIR_DOCKER_BASE_THISUSER]}/${_CONF[DIR_DOCKER_VOLUMES_THISUSER]}"
fi


###
### initial check
###

_init


##
## subcommands
##
function _recker-cut() {
    local curentWidth=$(tput cols)
    local suitableWidth=$((curentWidth-1))
    cat - | cut -b -$suitableWidth
}

function _recker-images() {
    local opt=''
    if [[ "${1-}" = '-a' ]]; then
        opt='-at'
        shift
    fi
    ${_DOCKER-} images $opt 2> /dev/null | _recker-cut
}

function _recker-images-a() {
    _recker-images -a
}

function _recker-ps() {
    local opt=''
    if [[ "${1-}" = '-a' ]]; then
        opt='-a'
        shift
    fi
    ${_DOCKER-} ps $opt $@ | _recker-cut
}

function _recker-ps-a() {
    _recker-ps -a "$@"
}

function _recker-version() {
    echo "Recker version $_VERSION"
}

function _recker-usage(){
    _showUsage
}

function _recker-help(){
    _recker-usage
}

function _recker-man(){
    _recker-usage
}

###
### subcommand for scaffolding
###

### template: Dockerfile
mapfile _T_DOCKERFILE <<'_EOF_'
FROM %%BASE_IMAGE%%
ARG RUN_AS_SERVICE
ARG VOLUMES
ARG PORTS
ARG LINKS
ARG EXEC
ARG SWAPPY
ARG OOMK_CANCEL

# Upload setup scripts
ADD _upload /tmp/_upload
ADD container_build.sh /var/recker/usr/container_build.sh
ADD container_services.sh /var/recker/usr/container_services.sh
RUN \
    mkdir -p \
        /var/recker/lib \
        /var/recker/usr \
        /var/recker/tar \
        /var/recker/log \
        && \
    chmod +x /var/recker/usr/container_build.sh && \
    ln -s /var/recker/usr/container_build.sh /tmp/container_build.sh && \
    chmod +x /var/recker/usr/container_services.sh && \
    ln -s /var/recker/usr/container_services.sh /etc/container_services.sh && \
    mv /tmp/_upload/container_lib.sh /var/recker/lib/container_lib.sh && \
    chmod +x /var/recker/lib/container_lib.sh && \
    mv /tmp/_upload/envs_onbuild.sh /var/recker/lib/envs_onbuild.sh

# I need bash ;(
RUN \
    [ ! -x /bin/bash ] \
    && if grep -q Alpine /etc/issue; then \
        apk add --update bash && rm -rf /var/cache/apk/* ; \
    fi

# Preparation checker
RUN \
    /bin/echo -e '#!/bin/bash\n\
[[ -f /var/recker/log/container_runonce.sh.done ]] \
    || exit 1\n\
' > /usr/local/bin/is_preparation_done \
    && chmod +x /usr/local/bin/is_preparation_done

# Set entry point shell script
RUN \
    /bin/echo -e '#!/bin/bash\n\
: > /var/recker/log/container.log\n\
exec >>/var/recker/log/container.log\n\
exec 2>&1\n\
[[ -f /var/recker/lib/container_lib.sh ]] \\\n\
    && source /var/recker/lib/container_lib.sh \n\
[[ -f /var/recker/lib/envs_onbuild.sh ]] \\\n\
    && source /var/recker/lib/envs_onbuild.sh \n\
[[ \\\n\
    -z "${VOLUMES-}" \\\n\
    || "${DONT_PRESERVE_SHARED_VOLUME-}" -eq 1 \\\n\
]] \\\n\
    || _cUntarSharedVolumes\n\
[[ \\\n\
    ! -f /var/recker/log/container_runonce.sh.done \\\n\
    && -f /var/recker/usr/container_runonce.sh \\\n\
]] \\\n\
    && source /var/recker/usr/container_runonce.sh \\\n\
    && touch /var/recker/log/container_runonce.sh.done \n\
[[ -f /var/recker/usr/container_services.sh ]] \\\n\
    && source /var/recker/usr/container_services.sh \n\
while true; do sleep 10; done\n\
' \
        > /var/recker/lib/core_init.sh\
    && chmod +x /var/recker/lib/core_init.sh \
    && if grep -q Alpine /etc/issue; then \
        echo -e '#!/bin/bash\n\
set -eu\n\
/sbin/start-stop-daemon \
    --start \
    --pidfile /var/run/core_init.pid \
    --make-pidfile \
    --background \
    --exec /var/recker/lib/core_init.sh \
    || exit 1 \n\
' \
            > /etc/local.d/container.start \
        && chmod +x /etc/local.d/container.start ;\
    else \
        echo -e '#!/bin/bash\n\
set -eu\n\
source /var/recker/lib/core_init.sh\n\
' \
            > /etc/container_init.sh \
        && chmod +x /etc/container_init.sh ; \
    fi

# Build and cleaning up
RUN \
    chmod +x /tmp/container_build.sh \
    && touch /var/recker/log/build.log \
    && bash -c '( \
        source /var/recker/lib/envs_onbuild.sh && \
        source /var/recker/lib/container_lib.sh && \
        source /tmp/container_build.sh && \
        _cPreserveSharedVolumes \
    ) ' 2>&1 \
        | tee -a /var/recker/log/build.log
RUN \
    /bin/rm /tmp/container_build.sh \
    && /bin/rm -r /tmp/_upload
_EOF_

### template: container_build.sh
mapfile _T_CONTAINER_BUILD_SH <<'_EOF_'
#!/bin/bash

# __WRITE_HERE_HOW_TO_BUILD_CONTAINER__

# _cSetScriptFor1stRuntime sets STDIN to container's first
# runtime script.
# example)
#_cSetScriptFor1stRuntime <<'______SCRIPT_FOR_1ST_RUNTIME'
#    :
#______SCRIPT_FOR_1ST_RUNTIME
# __WRITE_HERE_1ST_RUNTIME_SCRIPT__

# _cSetScriptContainerServices sets STDIN as a script for
# bootstrap container's services.
# example)
#_cSetScriptContainerServices <<'______SCRIPT_FOR_SERVICES'
#    :
#______SCRIPT_FOR_SERVICES
# __WRITE_HERE_SERVICE_SCRIPT__

_EOF_

### template: config.sh
mapfile _T_CONFIG_SH <<'_EOF_'
RUN_AS_SERVICE=
EXEC=
AUTOMAP_PORT_HTTP=
AUTOMAP_PORT_SSH=
VOLUMES=
PORTS=
LINKS=
BASE_IMAGE=%%BASE_IMAGE%%
COMMAND_POST_RUN=
PRIVILEGED=
PERMIT_CLEANUP="CONTAINER IMAGE VOLUME USER DB_USER DATABASE FILE DIR"
BACKUP_BEFORE_CLEANUP="VOLUME DATABASE"
#SET VARIABLENAME=VARIABLEVALUE
_EOF_

### template: pre_build.sh
mapfile _T_PRE_BUILD_SH <<'_EOF_'
#!/bin/bash

# __WRITE_HERE_PRE_BUILD_PROCESS__

_EOF_

### template: post_build.sh
mapfile _T_POST_BUILD_SH <<'_EOF_'
#!/bin/bash

# __WRITE_HERE_POST_BUILD_PROCESS__

_EOF_

### template: container_services.sh
mapfile _T_CONTAINER_SERVICES_SH <<'_EOF_'
#!/bin/bash

# `container_services.sh` is now obsolete.
# Please use `_cSetScriptContainerServices` in `container_build.sh`
# But this file will be treated properly for the sake of compatibility.
_EOF_

function _recker-scaffold(){
    local _longOpts
    while [[ \
        -n "${1-}" \
        && "${1-}" =~ ^--[a-zA-Z0-9_][a-zA-Z0-9_=\"-][a-zA-Z0-9_=\"-]* \
    ]]
    do
       _longOpts="${_longOpts-} ${1-}"
       shift
    done
    local -A __opts=$( _getOptsArray ${_longOpts-} )

    local _optImage
    if [[ "${__opts[image]-}" || "${__opts[img]-}" ]]; then
        _optImage="${__opts[image]-}""${__opts[img]-}"
    fi

    local _name=''
    local i
    if [[ "${1-}" ]]; then
        _name="${1-}"
        shift
    else
        _warn "specify name for scaffolding new Dockerfile"
        return 1
    fi

    local _optRecommendScriptFor
    if [[ ${__opts[recommend_script_for]-} ]]; then
        _optRecommendScriptFor="${__opts[recommend_script_for]-}"
    fi

    local _context="${_CONF[DIR_DOCKER_BASE_GLOBAL]-}/${_CONF[DIR_DOCKER_DOCKERFILES]-}/${_name-}"
    [[ $(_getEuid) -ne 0 ]] \
        && _context="${_CONF[DIR_DOCKER_DOCKERFILES_THISUSER]-}/${_name-}"

    if [[ -d "${_context-}" ]]; then
        _warn "that context already exists: ${_context-}"
        return 1
    fi

    local _imgName="${_name-}"
    local _maintainerName="${USER-}"
    [[ -n "${_CONF[DOCKER_MAINTAINER_NAME]-}" ]] \
        && _maintainerName="${_CONF[DOCKER_MAINTAINER_NAME]}"

    local -A _ICONF
    local _imgConfigFile="${_context-}/config.sh"
    if [[ -r "${_imgConfigFile-}" ]]; then
        source <( \
            grep '^[A-Z0-9_]\{1,\}=.*$' "${_imgConfigFile-}" \
            | grep -v '^SET[[:blank:]]' \
            | sed -e 's|^\([A-Z0-9_]\{1,\}\)\(=.*\)$|_ICONF[\1]\2|' \
        )
    fi

    for i in _upload
    do
        _makeSureDir "${_context-}/$i"
    done
    local _fn=''
    local _tn=''
    local _t=''
    local _key=''
    local -A _VARS=(
        [BASE_IMAGE]="${_CONF[DOCKER_BUILD_BASE_IMG]-}"
    )
    [[ -n "${_ICONF[BASE_IMG]-}" ]] \
        && _VARS[BASE_IMAGE]="${_ICONF[BASE_IMG]-}"
    [[ ! -z "${_optImage-}" ]] \
        && _VARS[BASE_IMAGE]="${_optImage-}"
    for i in \
        Dockerfile container_build.sh config.sh \
        pre_build.sh post_build.sh \
        ;
    do
        _fn=$i
        _tn="${i//./_}"
        _tn="_T_${_tn^^}"
        _t=$( eval "printf %s \"\${${_tn-}[@]}\"" )
        for _key in "${!_VARS[@]}"
        do
            _t="${_t//%%${_key-}%%/${_VARS[${_key-}]-}}"
        done
        echo "${_t-}" > "${_context-}/${_fn-}"
        [[ "${_fn-}" = 'Dockerfile' || "${_fn-}" = 'config.sh' ]] \
            || chmod +x "${_context-}/${_fn-}"
    done

    if [[ ${__opts[with_sysinit]-} ]]; then
        __opts[conf_run_as_service]=1
        __opts[conf_privileged]=1
        __opts[conf_exec]=/sbin/init
    fi

    _fn="${_context-}/config.sh"
    local _value
    for i in ${!__opts[@]};
    do
        if [[ \
            "${i-}" =~ ^[A-Za-z0-9_-][A-Za-z0-9_-]*$ \
            && "${i-}" =~ ^conf \
        ]]; then
            :
        else
            continue
        fi
        _value=${__opts[${i-}]-}
        i=${i#conf-}
        i=${i#conf_}
        i=${i^^}
        if grep -q "^${i-}" ${_fn}; then
            sed -i \
                -e "s|^\(${i-}\)=.\{0,\}\$|\1=${_value-}|" \
                    ${_fn-}
        else
            echo "${i-}=${_value-}" >> ${_fn-}
        fi
    done

    if [[ "${_optRecommendScriptFor-}" ]]; then
        _fn="${_context-}/container_build.sh"
        local _dist=${_optRecommendScriptFor-}
        local _t
        function __setRecommend () {
            local _dist="${1}"
            local _type="${2}"
            [[ "${_type-}" ]] && _type="_${_type-}"
            local _tag="${3}"
            local _targetFile="${4}"
            _tn="_B_RECOMMEND_SCRIPT${_type-}_${_dist^^}"
            _t=$( eval "printf %s \"\${${_tn-}[@]}\"" )
            if [[ "${_t-}" ]]; then
                local _counterPart=$(\
                    echo "${_t-}" \
                        | sed -e 's|\\|\\\\|g' -e 's|\&|\\&|g'\
                        | sed -r ':loop; N; $!b loop; s/[\r\n]/\\\\n/g'
                )
                sed -i \
                    -e "s?^\(\#[[:blank:]]\{1,\}${_tag-}\)\$?\1\n${_counterPart-}?" \
                    -e 's?\\n?\n?g' \
                    ${_targetFile-}
            fi
        }
        __setRecommend \
            "${_dist-}" \
            "" \
            "__WRITE_HERE_HOW_TO_BUILD_CONTAINER__" \
            "${_fn-}"
        __setRecommend \
            "${_dist-}" \
            "1STRUNTIME" \
            "__WRITE_HERE_1ST_RUNTIME_SCRIPT__" \
            "${_fn-}"
        __setRecommend \
            "${_dist-}" \
            "SERVICES" \
            "__WRITE_HERE_SERVICE_SCRIPT__" \
            "${_fn-}"
    fi

    _mention "scaffolding completed in context: ${_context-}"
}


###
### subcommands depends on percol
###

###
### Built-in files for building images
###

### File-content: container_lib.sh
### for _print_container_lib_sh
mapfile _B_CONTAINER_LIB_SH <<'_EOF_BUILT_IN_FILE'
#!/bin/bash

# Check distribution
DIST='unknown'
ISSUES=$( cat /etc/issue ) || DIST='unknown'
[[ ${ISSUES-} =~ 'CentOS' ]]      && DIST='centos'
[[ ${ISSUES-} =~ 'GNU/Linux' ]]   && DIST='debian'
[[ ${ISSUES-} =~ 'Alpine' ]]      && DIST='alpine'
function _cIsDist () {
    [[ ${DIST-} =~ "${1-}" ]] && return
    return 1
}

ARCH='unknown'
MACHINE=$( uname -m ) || ARCH='unknown'
[[ ${MACHINE-} =~ 'arm' ]]        && ARCH='arm'
[[ ${MACHINE-} =~ 'x86' ]]        && ARCH='x86'
[[ ${MACHINE-} =~ 'x86_64' ]]     && ARCH='x86_64'
function _cIsArch () {
    [[ ${ARCH-} =~ "${1-}" ]] && return
    return 1
}

# File path
_C_BASHRC=''
case "${DIST-}" in
    centos )
        _C_BASHRC='/etc/bashrc'
        ;;
    debian )
        _C_BASHRC='/etc/bash.bashrc'
        ;;
esac

# Services
function _cRunServices() {
    for i in "$@"
    do
        [[ -x systemctl ]] && \
            systemctl start $i || \
            service $i start
    done
}

# Strip strange Docker args/envs
function _cStripEnv() {
    [[ "${1-}" ]] || return
    local _e="${1#\"}"
    _e="${_e%\"}"
    echo ${_e//__/ }
}

# Tar shared volumes
function _cTarSharedVolumes() {
    [[ "$@" ]] || return 1
    mkdir -p /var/recker/tar
    tar \
        cvzf \
        /var/recker/tar/shared_dirs.tgz \
        --directory / \
        --preserve-permissions \
        $@
#        --acls \
#        --xattrs \
}

# Untar shared volumes
function _cUntarSharedVolumes() {
    [[ -r /var/recker/tar/shared_dirs.tgz ]] || return 1
    tar \
        xvzf \
        /var/recker/tar/shared_dirs.tgz \
        --directory / \
        --preserve-permissions \
        --overwrite \
        --overwrite-dir
#        --acls \
#        --xattrs
}

#
function _cPreserveSharedVolumes () {
    [[ -z "${VOLUMES-}" || "${DONT_PRESERVE_SHARED_VOLUME-}" -eq 1 ]] \
        && return
    _cTarSharedVolumes ${VOLUMES-}
}

#
function _cSetScriptFor1stRuntime () {
    cat <<'_EOF_' > /var/recker/usr/container_runonce.sh
#!/bin/bash
_EOF_
    cat - >> /var/recker/usr/container_runonce.sh
    chmod +x /var/recker/usr/container_runonce.sh
}

#
function _cSetScriptContainerServices () {
    cat <<'_EOF_' > /var/recker/usr/container_services.sh
#!/bin/bash
_EOF_
    cat - >> /var/recker/usr/container_services.sh
    chmod +x /var/recker/usr/container_services.sh
}


_EOF_BUILT_IN_FILE

mapfile _B_RECOMMEND_SCRIPT_CENTOS <<'_EOF_BUILT_IN_FILE'
_cIsDist centos \
&& {
    echo 'ZONE="Asia/Tokyo"' > /etc/sysconfig/clock
    /bin/rm /etc/localtime
    ln -fs /usr/share/zoneinfo/Asia/Tokyo /etc/localtime
    [[ "${_C_BASHRC}" ]] && \
        echo '[[ "${PS1-}" ]] && PS1=":D $PS1"' >> ${_C_BASHRC}
}
_EOF_BUILT_IN_FILE

mapfile _B_RECOMMEND_SCRIPT_1STRUNTIME_CENTOS <<'_EOF_BUILT_IN_FILE'
#
_EOF_BUILT_IN_FILE

mapfile _B_RECOMMEND_SCRIPT_SERVICES_CENTOS <<'_EOF_BUILT_IN_FILE'
#
_EOF_BUILT_IN_FILE

# Debian
mapfile _B_RECOMMEND_SCRIPT_DEBIAN <<'_EOF_BUILT_IN_FILE'
_cIsDist debian \
&& {
    [[ "${_C_BASHRC}" ]] && \
        echo '[[ "${PS1-}" ]] && PS1=":D $PS1"' >> ${_C_BASHRC}
}
_EOF_BUILT_IN_FILE

mapfile _B_RECOMMEND_SCRIPT_1STRUNTIME_DEBIAN <<'_EOF_BUILT_IN_FILE'
#
_EOF_BUILT_IN_FILE

mapfile _B_RECOMMEND_SCRIPT_SERVICES_DEBIAN <<'_EOF_BUILT_IN_FILE'
#
_EOF_BUILT_IN_FILE

# Alpine Linux
mapfile _B_RECOMMEND_SCRIPT_ALPINE <<'_EOF_BUILT_IN_FILE'
_cIsDist alpine \
&& {
    sed -i \
        -e 's/#rc_sys=""/rc_sys="lxc"/g' \
        -e 's/^#\(rc_logger="YES"\)$/\1/' \
            /etc/rc.conf
    echo 'rc_provide="loopback net"' >> /etc/rc.conf
    sed -i 's|^tty|#tty|' /etc/inittab
    echo 'id:3:initdefault:' >> /etc/inittab
    echo 'Asia/Tokyo' > /etc/timezone
    cat <<'_EOF' > /etc/network/interfaces
auto lo
iface lo inet loopback
allow-hotplug eth0
iface eth0 inet dhcp
_EOF
    for i in \
        urandom procfs devfs sysctl dmesg loopback \
        cron syslog local
    do
        rc-update add $i
    done
}
_EOF_BUILT_IN_FILE

mapfile _B_RECOMMEND_SCRIPT_1STRUNTIME_ALPINE <<'_EOF_BUILT_IN_FILE'
#
_EOF_BUILT_IN_FILE

mapfile _B_RECOMMEND_SCRIPT_SERVICES_ALPINE <<'_EOF_BUILT_IN_FILE'
_cSetScriptContainerServices <<'______SCRIPT_FOR_SERVICES'
ip addr flush dev lo
rc-service networking start
______SCRIPT_FOR_SERVICES
_EOF_BUILT_IN_FILE

###
### Functions for building images
###

### pre/post-build functions for end-users
function _pWarn() {
    echo -e "\e[31m[PREBUILD] $@\e[m" >&2
}

function _pGetHostUserUId () {
    local _USER="${1-}"
    if [[ "${_USER-}" ]] && grep -q "^${_USER-}" /etc/passwd ; then
        :
    else
        _pWarn "User unspecified or unknown user : ${_USER-}"
        exit 1
    fi
    grep "^${_USER-}" /etc/passwd \
        | cut -d : -f 3
}

function _pGetHostUserGId () {
    local _USER="${1-}"
    if [[ "${_USER-}" ]] && grep -q "^${_USER-}" /etc/passwd ; then
        :
    else
        _pWarn "User unspecified or unknown user : ${_USER-}"
        exit 1
    fi
    grep "^${_USER-}" /etc/passwd \
        | cut -d : -f 4
}

function _pAddToBeCleaned () {
    echo "$@" >> ${_context-}/.tobecleaned
}

function _pAddUserToHost () {
    local _USER="${1-}"
    shift
    if [[ "${_USER-}" ]] && ! grep -q "^${_USER-}" /etc/passwd ; then
        :
    else
        _pWarn "User unspecified or user already exists: ${_USER-}"
        exit 1
    fi
    useradd \
        --create-home \
        --user-group \
        $@ \
        ${_USER-}
    _pAddToBeCleaned "USER: ${_USER-}"
}

function _pPassEnv () {
    local KEY_VALUE="$@"
    if [[ "${KEY_VALUE-}" =~ ^[^=][^=]*=[^=][^=]*$ ]]; then
        :
    else
        return 1
    fi
    echo "_P_${KEY_VALUE-}" >> _upload/envs_onbuild.sh
}

function _pExecSQL () {
    local _connection=${1-}
    shift
    local _host=${_connection##*@}
    local _user=${_connection%@*}
    local _passwd=${_user#*:}
    _user=${_user%%:*}
    if [[ "${_host-}" && "${_user-}" && "${_passwd-}" ]]; then
        :
    else
        _pWarn "Insufficient arguments: ${_connection-}"
        exit 1
    fi
    local _additional_args="$@"
    [[ -n "${_additional_args-}" ]] \
        && _additional_args='--silent'
    local _sql=$( cat - )
    [[ -n "${VERBOSE-}" ]] \
        && _warn "$_sql"
    echo "$_sql" | /usr/bin/mysql \
        ${_additional_args-} \
        --host=${_host-} \
        --user=${_user-} \
        --password=${_passwd-}
    return $?
}

function _pIsDatabaseExists () {
    local _database=${1-}
    local _connection=${2-}

    if [[ "${_database-}" && "${_connection-}" ]]; then
        :
    else
        _pWarn "Insufficient arguments: ${_database-} ${_connection-}"
        exit 1
    fi


    if [[ -n $( \
        echo "SHOW DATABASES LIKE '${_database-}';" \
            | _pExecSQL "${_connection-}" \
    ) ]]; then
        :
    else
        return 1
    fi
}

function _pIsDBUserExists () {
    local _user=${1-}
    local _connection=${2-}

    if [[ "${_user-}" && "${_connection-}" ]]; then
        :
    else
        _pWarn "Insufficient arguments: ${_user-} ${_connection-}"
        exit 1
    fi

    if [[ -n $( \
        echo "SELECT User FROM mysql.user WHERE user='${_user-}';" \
            | _pExecSQL "${_connection-}" \
    ) ]]; then
        :
    else
        return 1
    fi
}

function _pDropDBandUserIfExists () {
    local _database=${1-}
    local _user=${2-}
    local _connection=${3-}

    if [[ "${_database-}" && "${_user-}" && "${_connection-}" ]]; then
        :
    else
        _pWarn "Insufficient arguments: "${_database-}" ${_user-} ${_connection-}"
        exit 1
    fi

    _pDropDBUserIfExists "${_user-}" "${_connection-}"
    _pDropDatabaseIfExists "${_database-}" "${_connection-}"
}

function _pDropDBUserIfExists () {
    local _user=${1-}       # NOTE: you must specify %hostname postfix
    local _connection=${2-}

    if [[ "${_user-}" && "${_connection-}" ]]; then
        :
    else
        _pWarn "Insufficient arguments: ${_user-} ${_connection-}"
        exit 1
    fi

    if ! _pIsDBUserExists ${_user-} "${_connection-}"; then
        return
    fi

    _pExecSQL "${_connection-}" <<_EOF_
DROP USER ${_user-}
FLUSH PRIVILEGES;
_EOF_
}

function _pDropDatabaseIfExists () {
    local _database=${1-}
    local _connection=${2-}

    if [[ "${_database-}" && "${_connection-}" ]]; then
        :
    else
        _pWarn "Insufficient arguments: ${_database-} ${_connection-}"
        exit 1
    fi

    echo "DROP DATABASE IF EXISTS \`${_database-}\`;" \
        | _pExecSQL "${_connection-}"
}

function _pCreateDatabaseAndUserIfNotExists () {
    local _database=${1-}
    local _connection=${2-}
    local _newUserPasswd=${3-}

    if [[ \
        "${_database-}" \
        && "${_connection-}" \
        && "${_newUserPasswd-}" \
    ]]; then
        :
    else
        _pWarn "Insufficient arguments: ${_database-} ${_connection-} ${_newUserPasswd-}"
        exit 1
    fi

    if _pIsDatabaseExists ${_database-} "${_connection-}"; then
        return
    fi

    local _user=${_newUserPasswd%:*}
    local _passwd=${_newUserPasswd#*:}
    if [[ "${_user-}" && "${_passwd-}" ]]; then
        :
    else
        _pWarn "Insufficient arguments: ${_newUserPasswd-}"
        exit 1
    fi

    _pExecSQL "${_connection-}" \
<<_EOF_
CREATE
    DATABASE \`${_database-}\`
    DEFAULT CHARACTER SET utf8
;
_EOF_
    _pAddToBeCleaned "DATABASE: ${_database-} ${_connection-}"

    for _host in localhost 127.0.0.1 172.%;
    do
        _pExecSQL "${_connection-}" \
<<_EOF_
GRANT
    ALL PRIVILEGES
    ON \`${_database-}\`.*
    TO '${_user-}'@'${_host-}'
    IDENTIFIED BY '${_passwd-}'
;
_EOF_
        _pAddToBeCleaned "DB_USER: ${_user-}@${_host-} ${_connection-}"
    done
}

function _pBackupDatabaseIfExists () {
    local _database=${1-}
    local _connection=${2-}

    _pIsDatabaseExists ${_database-} ${_connection-} \
        || return
    local _dirBak="${_context-}/_bak"
    [[ -d ${_dirBak-} ]] \
        || mkdir -p ${_dirBak-}
    [[ ! -f "${_dirBak-}/.dockerignore" ]] \
        && echo '*' > "${_dirBak-}/.dockerignore"
    _pDumpDatabase ${_database-} ${_connection-} \
        | gzip \
        > ${_dirBak-}/mysqldump-${_database}-$(date '+%Y%m%d-%H%M').tgz
}

function _pDumpDatabase () {
    local _database=${1-}
    local _connection=${2-}
    local _host=${_connection##*@}
    local _user=${_connection%@*}
    local _passwd=${_user#*:}
    _user=${_user%%:*}

    if [[ \
        "${_database-}" \
        && "${_connection-}" \
    ]]; then
        :
    else
        _pWarn "Insufficient arguments: ${_database-} ${_connection-}"
        exit 1
    fi

    if _pIsDatabaseExists ${_database-} "${_connection-}"; then
        :
    else
        return 1
    fi

    [[ "$VERBOSE" ]] \
        && cat <<_EOF_ >&2
    mysqldump \
        --host=${_host-} \
        --user=${_user-} \
        --password=${_passwd-} \
        --opt \
        --single-transaction \
        --events \
        --default-character-set=binary \
        --add-drop-database \
        --add-drop-table \
        ${_database-}
_EOF_
    mysqldump \
        --host=${_host-} \
        --user=${_user-} \
        --password=${_passwd-} \
        --opt \
        --single-transaction \
        --events \
        --default-character-set=binary \
        --add-drop-database \
        --add-drop-table \
        ${_database-}
}

function _pHas() {
    local _list="${1-}"
    local _elem="${2-}"
    [[ -z "${_list-}" || -z "${_elem-}" ]] \
        && return 1
    echo "${_list-}" | tr ' ' '\n' | grep -q '^'${_elem-}'$' \
        || return 1
}

function _pDropDatabaseAndUserIfPermitted () {
    local _user=${1-}
    local _database=${2-}
    local _connection=${3-}
    if ! _pHas "${_ICONF[PERMIT_CLEANUP]-}" DATABASE; then
        return
    fi
    if [[ "${_user-}" && "${_database-}" && "${_connection-}" ]]; then
        :
    else
        _pWarn "Insufficient arguments: ${_user-} ${_database-} ${_connection-}"
        exit 1
    fi

    for _host in localhost 127.0.0.1 172.%;
    do
        _pDropDBUserIfExists \
            ${_user-}@${_host-} \
            ${CONN-} || _pWarn $?
    done

    _pDropDatabaseIfExists \
        ${_database-} \
        ${CONN-}
}

function _pMakeFileWithPreservation () {
    local _file="${1-}"
    if [[ -z "${_file}" ]]; then
        _warn "Insufficient arguments: ${_file-}"
        exit 1
    fi

    local _dir="${_file%/*}"
    [[ ! -d "${_dir-}" ]] \
        && mkdir -p ${_dir-}

    local _tempFile=$( mktemp )
    cat - > ${_tempFile-}
    if [[ -f "${_file-}" ]]; then
        if [[ -f "${_file-}.save" ]]; then
            diff \
                --ignore-tab-expansion \
                --ignore-trailing-space \
                --ignore-space-change \
                --ignore-blank-lines \
                "${_file-}.save" "${_file-}" > /dev/null \
                    || cp "${_file-}" "${_file-}.save"
        else
            cp "${_file-}" "${_file-}.save"
        fi
    fi
    mv ${_tempFile-} ${_file-}
    _pAddToBeCleaned "FILE: ${_file-}"
}

###
### recker clean
###
function _recker-clean() {
    local _longOpts
    while [[ \
        -n "${1-}" \
        && "${1-}" =~ ^--[a-zA-Z0-9_][a-zA-Z0-9_=\"-][a-zA-Z0-9_=\"-]* \
    ]]
    do
       _longOpts="${_longOpts-} ${1-}"
       shift
    done
    local -A __opts=$( _getOptsArray ${_longOpts-} )

    local _optMore
    if [[ "${__opts[more]-}" ]]; then
        _optMore=1
    fi

    # not implemented
    local _optMust
    if [[ "${__opts[ignore-log-absence]-}" ]]; then
        _optMust=1
    fi

    local _units
    if [[ "${__opts[units]-}" ]]; then
        _units="${__opts[units]//,/ }"
    fi

    local _context=''
    if [[ "${1-}" ]]; then
        _context="${1-}"
        shift
        if [[ \
            -d "${_context-}" \
            && "${_context-}" =~ ^[^/] \
        ]]; then
            _context=$(cd ${_context-} && pwd)
        fi
    else
        _context=$( \
            ${_RECKER_ABS-} _comp dockerfile-and-images-name \
            | ${_PERCOL-} --prompt='Recker clean' \
        )
    fi

    if [[ ! "${_context-}" ]]; then
        _warn "specify context directory or image name..."
        return 1
    fi
    local _howMany=(${_context-})
    if [[ ${#_howMany[@]} -gt 1 ]]; then
        _warn "too much target to cleaning..."
        return 1
    fi

    local _maintainerName="${USER-}"
    [[ -n "${_CONF[DOCKER_MAINTAINER_NAME]-}" ]] \
        && _maintainerName="${_CONF[DOCKER_MAINTAINER_NAME]}"
    local _imgName="${_context-}"
    local _imgToExec=''
    local _isUnderRecker=0
    local _imgConfigFile=''
    local -A _ICONF
    if [[ -d "${_imgName-}" ]]; then
        _imgName="${_imgName##*/}"
        _imgToExec="${_maintainerName-}/${_imgName-}"
        _isUnderRecker=1
        _imgConfigFile="${_context-}/config.sh"
        if [[ -r "${_imgConfigFile-}" ]]; then
            source <(
                grep '^[A-Z0-9_]\{1,\}=.*$' "${_imgConfigFile-}" \
                | grep -v '^SET[[:blank:]]' \
                | sed -e 's|^\([A-Z0-9_]\{1,\}\)\(=.*\)$|_ICONF[\1]\2|' \
            )
            local _envs=$(
                grep '^SET[[:blank:]]' "${_imgConfigFile-}" \
                | sed -e 's|^SET[[:blank:]]\{1,\}\([^=[:blank:]]\{1,\}\)="\(.*\)"$|\1=\2|;' \
                    -e 's| |__|g'
            )
            _envs=$(
                echo "${_envs-}" \
                | grep -v '^$' \
                | sed -e 's|^|-e |' \
                | tr '\n' ' ' \
            )
        fi
    else
        _imgToExec="${_imgName-}"
        _imgName="${_imgName//\//_}"
        _imgName="${_imgName//:/_}"
    fi

    if [[ \
        ! -f ${_context-}/.tobecleaned \
        && -z "${_optMust-}" \
    ]]; then
        _warn 'nothing to clean up'
        return
    fi

    local -A _p
    _p[NAME_IMAGE]="${_imgName-}"
    _p[NAME_MAINTAINER]="${_maintainerName-}"
    _p[DIR_DOCKER_BASE]="${_CONF[DIR_DOCKER_BASE_GLOBAL]-}"
    [[ $(_getEuid) -ne 0 ]] \
        && _p[DIR_DOCKER_BASE]="${_CONF[DIR_DOCKER_BASE_THISUSER]-}"
    _p[DIR_DOCKER_VOLUMES]="${_p[DIR_DOCKER_BASE]-}/${_CONF[DIR_DOCKER_VOLUMES]-}"

    local _dirBak="${_context-}/_bak"
    function __makeBackupDirectory () {
        [[ ! -d "${_dirBak-}" ]] && mkdir -p ${_dirBak-}
        [[ ! -f "${_dirBak-}/.dockerignore" ]] \
            && echo '*' > "${_dirBak-}/.dockerignore"
    }

    function __eraseRemoveEntry () {
        local _target="$@"
        [[ ! "${_target-}" ]] && return
        [[ ! -f ${_context-}/.tobecleaned ]] && return
        sed -i \
            -e "s|^${_target-}\$||g" \
            -e '/^$/d' \
                ${_context-}/.tobecleaned
    }

    [[ -z "${_units-}" ]] \
        && _units="${_ICONF[PERMIT_CLEANUP]-}"

    _mention "Started to clean up docker context resources..."

    if _has "${_ICONF[PERMIT_CLEANUP]-}" CONTAINER; then
        ! _has "${_units-}" CONTAINER \
            || {
                _mention " - containers..."
                local _containerToKill
                for _containerToKill in \
                    $( \
                        ${_DOCKER-} ps -a \
                        | tail -n +2 \
                        | grep '^[^[:blank:]]\{1,\}[[:blank:]]\{1,\}'"${_maintainerName-}/${_imgName-}" \
                        | sed -e 's/^.*[[:blank:]]\{1,\}\([^[:blank:]]\{1,\}\)[[:blank:]]\{0,\}$/\1/'
                    )
                do
                    __eraseRemoveEntry "CONTAINER: ${_containerToKill-}"
                    recker stop-rm ${_containerToKill-}
                done
            }
    fi

    if _has "${_ICONF[PERMIT_CLEANUP]-}" IMAGE; then
        ! _has "${_units-}" IMAGE \
            || {
                _mention " - images ( including garbages )..."
                local _targetImage
                for _targetImage in \
                    "$( grep '^IMAGE:' ${_context-}/.tobecleaned | cut -d ' ' -f 2 )"
                do
                    [[ "${_targetImage-}" ]] \
                        && ${_DOCKER-} rmi ${_targetImage}
                    __eraseRemoveEntry "IMAGE: ${_targetImage-}"
                done
                for _targetImage in \
                    "$( ${_DOCKER-} images | grep '^<none>' | awk '{print $3}' )"
                do
                    [[ "${_targetImage-}" ]] \
                        && ${_DOCKER-} rmi ${_targetImage}
                done
            }
    fi

    if _has "${_ICONF[PERMIT_CLEANUP]-}" VOLUME; then
        ! _has "${_units-}" VOLUME \
            || {
                _mention " - shared volumes..."
                local _volumeDir
                for _volumeDir in \
                    $( \
                        grep '^VOLUME:' ${_context-}/.tobecleaned | cut -d ' ' -f 2
                    )
                do
                    [[ ${_volumeDir} = '/var/recker/log' ]] \
                        && continue
                    if [[ ! -d ${_volumeDir} ]]; then
                        _mention "     No such directory: ${_volumeDir}, skipped."
                        continue
                    fi
                    if \
                        _has "${_ICONF[BACKUP_BEFORE_CLEANUP]-}" VOLUME \
                        && [[ "${_optMore-}" -ne 1 ]] ;
                    then
                        __makeBackupDirectory
                        local _tgzName="${_volumeDir#/}"
                        _tgzName="${_tgzName//\//_}.tgz"
                        _mention "     Preserving volume: ${_volumeDir}"
                        tar czf "${_dirBak-}/${_tgzName-}" ${_volumeDir} 2>&1 \
                            | egrep -v '(Removing leading)'
                    fi
                    /bin/rm -rf ${_volumeDir}
                    __eraseRemoveEntry "VOLUME: ${_volumeDir}"
                done
                local _imagesVolumeTopDir=${_p[DIR_DOCKER_VOLUMES]-}/${_p[NAME_IMAGE]-}
                if [[ \
                    -n "${_imagesVolumeTopDir-}" \
                    && "${_imagesVolumeTopDir-}" != '/' \
                    && -d ${_imagesVolumeTopDir-} \
                    && $( find ${_imagesVolumeTopDir-} -type f | wc -l ) -le 0 \
                ]]; then
                    /bin/rm -rf ${_imagesVolumeTopDir-}
                fi
            }
    fi

    if _has "${_ICONF[PERMIT_CLEANUP]-}" USER; then
        ! _has "${_units-}" USER \
            || {
                _mention " - host-side users..."
                local _addedUser
                for _addedUser in \
                    $( \
                        grep '^USER:' ${_context-}/.tobecleaned | cut -d ' ' -f 2
                    )
                do
                    if \
                        grep -q "^${_addedUser-}:" /etc/passwd \
                        && [[ \
                            1000 \
                            -le \
                            $( grep "^${_addedUser-}:" /etc/passwd | cut -d : -f 3 ) \
                        ]]
                    then
                        (
                            userdel \
                                --remove \
                                ${_addedUser-} \
                                2>&1 \
                                | egrep -v '(mail spool.*not found)'
                        )
                        if ! grep -q "^${_addedUser-}:" /etc/passwd; then
                            _mention "     removed user: ${_addedUser-}"
                            __eraseRemoveEntry "USER: ${_addedUser-}"
                        fi
                    fi
                done
            }
    fi

    if _has "${_ICONF[PERMIT_CLEANUP]-}" DATABASE; then
        ! _has "${_units-}" DATABASE \
            || {
                _mention " - database..."
                local _addedDatabase
                for _addedDatabase in \
                    $( \
                        grep '^DATABASE:' ${_context-}/.tobecleaned \
                        | cut -d ' ' -f 2-3 \
                        | tr ' ' '#'
                    )
                do
                    if \
                        _has "${_ICONF[BACKUP_BEFORE_CLEANUP]-}" DATABASE \
                        && [[ "${_optMore-}" -ne 1 ]] ;
                    then
                        __makeBackupDirectory
                        _pDumpDatabase \
                            ${_addedDatabase//#/ } \
                            | gzip \
                            > ${_dirBak-}/mysqldump-${_addedDatabase%#*}.tgz
                    fi
                    _pDropDatabaseIfExists ${_addedDatabase//#/ } \
                        && __eraseRemoveEntry "DATABASE: ${_addedDatabase//#/ }"
                done
            }
    fi

    if _has "${_ICONF[PERMIT_CLEANUP]-}" DB_USER; then
        ! _has "${_units-}" DB_USER \
            || {
                _mention " - database users..."
                local _addedDatabaseUser
                for _addedDatabaseUser in \
                    $( \
                        grep '^DB_USER:' ${_context-}/.tobecleaned \
                            | cut -d ' ' -f 2-3 \
                            | tr ' ' '#'
                    )
                do
                    _pDropDBUserIfExists ${_addedDatabaseUser//#/ } \
                        && __eraseRemoveEntry "DB_USER: ${_addedDatabaseUser//#/ }"
                done
            }
    fi

    if _has "${_ICONF[PERMIT_CLEANUP]-}" FILE; then
        ! _has "${_units-}" FILE \
            || {
                _mention " - newly generated files..."
                local _addedFile
                for _addedFile in \
                    $( \
                        grep '^FILE:' ${_context-}/.tobecleaned \
                        | cut -d ' ' -f 2
                    )
                do
                    if [[ -f "${_addedFile-}" ]]; then
                        /bin/rm -f ${_addedFile-}
                        __eraseRemoveEntry "FILE: ${_addedFile-}"
                    fi
                done
            }
    fi

    if _has "${_ICONF[PERMIT_CLEANUP]-}" DIR; then
        ! _has "${_units-}" DIR \
            || {
                _mention " - newly generated directories..."
                local _genDir
                for _genDir in \
                    $( \
                        grep '^DIR:' ${_context-}/.tobecleaned \
                        | cut -d ' ' -f 2
                    )
                do
                    if [[ -d "${_genDir-}" ]]; then
                        if ! /bin/rmdir ${_genDir-}; then
                            _warn "${_genDir-} is not empty. Skipped."
                            continue
                        fi
                        __eraseRemoveEntry "DIR: ${_genDir-}"
                    fi
                done
            }
    fi

    grep -q -v '^$' ${_context-}/.tobecleaned \
        || rm -f ${_context-}/.tobecleaned

    if [[ \
        -d ${_dirBak-} \
        && ${_dirBak-} != '/' \
        && "${_optMore-}" -eq 1 \
    ]]; then
        _mention " - backup files..."
        /bin/rm -rf ${_dirBak-}
    fi

    _mention "Done."
}

###
### recker build
###
function _recker-build() {
    local _longOpts
    while [[ \
        -n "${1-}" \
        && "${1-}" =~ ^--[a-zA-Z0-9_][a-zA-Z0-9_=\"-][a-zA-Z0-9_=\"-]* \
    ]]
    do
       _longOpts="${_longOpts-} ${1-}"
       shift
    done
    local -A __opts=$( _getOptsArray ${_longOpts-} )

    local _optImage
    if [[ "${__opts[image]-}" || "${__opts[img]-}" ]]; then
        _optImage="${__opts[image]-}""${__opts[img]-}"
    fi

    local _context=''
    if [[ "${1-}" ]]; then
        _context="${1-}"
        shift
        if [[ \
            -d "${_context-}" \
            && "${_context-}" =~ ^[^/] \
        ]]; then
            _context=$(cd ${_context-} && pwd)
        fi
    else
        _context=$( \
            ${_RECKER_ABS-} _comp dockerfiles \
            | ${_PERCOL-} --prompt='Recker build' \
        )
    fi

    if [[ ! "${_context-}" ]]; then
        _warn "specify context directory..."
        return 1
    fi
    local _howMany=(${_context-})
    if [[ ${#_howMany[@]} -gt 1 ]]; then
        _warn "too much target to build..."
        return 1
    fi
    if [[ ! -d "${_context-}" ]]; then
        _warn "no such context directory..."
        return 1
    fi

    local -A _ICONF
    local -A _p
    _p['_Z']='Z'
    local -a _envsOnBuild
    local _imgConfigFile="${_context-}/config.sh"

    [[ ! "${DEBUG-}" && -f ${_context-}/.tobecleaned ]] \
        && _recker-clean \
            --units="CONTAINER,VOLUME,USER,DB_USER,DATABASE,FILE,DIR" \
            ${_context-}

    function __addToBeCleaned () {
        [[ ! -f ${_context-}/.tobecleaned ]] \
            && touch ${_context-}/.tobecleaned
        grep -q "$@" ${_context-}/.tobecleaned \
            || echo "$@" >> ${_context-}/.tobecleaned
    }

    if _makeSureDir "${_context-}/_upload"; then
        __addToBeCleaned "DIR: ${_context-}/_upload"
    else
        _die "Cannot mkdir ${_context-}/_upload"
    fi

    if \
        [[ ! -f "${_context-}/container_services.sh" ]] \
        || ! grep -v \
            -e '^[[:blank:]]\{0,\}#\{1,\}' \
            -e '^[[:blank:]]\{0,\}$' \
                "${_context-}/container_services.sh"
    then
        _t=$( eval "printf %s \"\${_T_CONTAINER_SERVICES_SH[@]}\"" )
        echo "${_t-}" > "${_context-}/container_services.sh"
        __addToBeCleaned "FILE: ${_context-}/container_services.sh"
    fi

    [[ -f "${_context-}/_upload/envs_onbuild.sh" ]] \
        && rm -f "${_context-}/_upload/envs_onbuild.sh"
    __addToBeCleaned "FILE: ${_context-}/_upload/container_lib.sh"
    if [[ -r "${_imgConfigFile-}" ]]; then
        source <( \
            grep '^[A-Z0-9_]\{1,\}=.*$' "${_imgConfigFile-}" \
            | grep -v '^SET[[:blank:]]' \
            | sed -e 's|^\([A-Z0-9_]\{1,\}\)\(=.*\)$|_ICONF[\1]\2|' \
        )
        _envsOnBuild=$(
            grep '^[A-Z0-9_]\{1,\}=.\{1,\}$' "${_imgConfigFile-}" \
            | egrep '^(RUN_AS_SERVICE|VOLUMES|PORTS|LINKS|EXEC|SWAPPY|OOMK_CANCEL)' \
            | sed -e 's| |__|' -e 's|^|--build-arg |' \
            | tr '\n' ' ' \
        )
        if [[ ${_DOCKER_VERSION-} -lt 10901 ]]; then
            _warn "build-arg option omitted because Docker version is lesser than 1.9.1"
            _envsOnBuild=''
        fi
        source <( \
            grep '^SET[[:blank:]]' "${_imgConfigFile-}" \
            | sed \
                -e 's|^SET[[:blank:]]\{1,\}\([^=[:blank:]]\{1,\}\)=\("\{0,\}.*"\{0,\}\)$|_p[\1]=\2|;' \
                -e 's| |__|g' \
        )
        grep -v '^SET[[:blank:]]' "${_imgConfigFile-}" \
            >> "${_context-}/_upload/envs_onbuild.sh"
        grep '^SET[[:blank:]]' "${_imgConfigFile-}" \
            | sed \
                -e 's|^SET[[:blank:]]\{1,\}\([^=[:blank:]]\{1,\}\)=\("\{0,\}.*"\{0,\}\)$|\1=\2|;' \
                -e 's| |__|g' \
            >> "${_context-}/_upload/envs_onbuild.sh"
        echo "DOCKER_HOST_IP=\"$(_getHostIPv4)\"" \
            >> "${_context-}/_upload/envs_onbuild.sh"
    fi

    local _baseImage="${_CONF[DOCKER_BUILD_BASE_IMG]-}"
    [[ -n "${_ICONF[BASE_IMAGE]-}" ]] \
        && _baseImage="${_ICONF[BASE_IMAGE]-}"
    local _fromImage=$( \
        grep '^FROM[[:blank:]]\{1,\}[^[:blank:]]\{1,\}$' \
            ${_context-}/Dockerfile \
        | sed 's|^FROM[[:blank:]]\{1,\}\([^[:blank:]]\{1,\}\)$|\1|'
    )
    [[ ! -z "${_optImage-}" ]] \
        && _baseImage="${_optImage-}"
    [[ -z "${_fromImage-}" ]] \
        && _die "'FROM' directive not found in Dockerfile. Corrupted?"
    [[ "${_fromImage-}" != "${_baseImage-}" ]] \
        && sed -i \
            -e "s|^\(FROM[[:blank:]]\{1,\}\).*\$|\1${_baseImage-}|" \
            ${_context-}/Dockerfile

    local _imgName="${_context##*/}"
    local _maintainerName="${USER-}"
    [[ -n "${_CONF[DOCKER_MAINTAINER_NAME]-}" ]] \
        && _maintainerName="${_CONF[DOCKER_MAINTAINER_NAME]}"

    _p[NAME_IMAGE]="${_imgName-}"
    _p[NAME_MAINTAINER]="${_maintainerName-}"
    _p[DIR_DOCKER_BASE]="${_CONF[DIR_DOCKER_BASE_GLOBAL]-}"
    [[ $(_getEuid) -ne 0 ]] \
        && _p[DIR_DOCKER_BASE]="${_CONF[DIR_DOCKER_BASE_THISUSER]-}"
    _p[DIR_DOCKER_VOLUMES]="${_p[DIR_DOCKER_BASE]-}/${_CONF[DIR_DOCKER_VOLUMES]-}"

    _mention "Started building: ${_context-}..."
    local _fn="${_context-}/pre_build.sh"
    if [[ -x "${_fn-}" ]]; then
        _mention "running pre_build.sh..."
        [[ ${DEBUG-} ]] && \
            _mention "You are in DEBUG mode. Skipped."
        [[ ${DEBUG-} ]] || ( \
            export -f $( declare -f | grep '^_p[A-Z].*\(\)' | sed 's/().*$//' )
            export _p
            recker _print_container_lib_sh \
                > "${_context-}/_upload/container_lib.sh"
            __addToBeCleaned "FILE: ${_context-}/_upload/container_lib.sh"
            cd ${_context-}
            source pre_build.sh
        )
    fi

    _mention "running 'docker build'..."
    if [[ ${DEBUG-} ]]; then
        cat <<_EOF_
            ${_DOCKER-} build \
                ${_CONF[DOCKER_BUILD_OPT]} \
                ${_envsOnBuild-} \
                -t "${_maintainerName-}/${_imgName-}" \
                ${_context-}
_EOF_
    else
        ${_DOCKER-} build \
            ${_CONF[DOCKER_BUILD_OPT]} \
            ${_envsOnBuild-} \
            -t "${_maintainerName-}/${_imgName-}" \
            ${_context-} \
        && __addToBeCleaned "IMAGE: ${_maintainerName-}/${_imgName-}"
    fi
    _fn="${_context-}/post_build.sh"
    if [[ -x "${_fn-}" ]]; then
        _mention "running post_build.sh..."
        [[ ${DEBUG-} ]] || ( \
            export -f $( declare -f | grep '^_p[A-Z].*\(\)' | sed 's/().*$//' )
            export _p
            cd ${_context-}
            source post_build.sh
        )
    fi
    _mention "build has completed."
    [[ -f "${_context-}/_upload/envs_onbuild.sh" ]] \
        && __addToBeCleaned "FILE: ${_context-}/_upload/envs_onbuild.sh"
}

function _recker-RUN-FGorBG() {
    local i
    local _action=''
    local _switchFgBg='-dt'
    if [[ "${1-}" =~ ^(fg|bg)$ ]]; then
        _action="${1-}"
        shift
        [[ "${_action-}" = 'fg' ]] \
            && _switchFgBg='-it --rm=true'
    else
        _die "[Error] Unknown action? ${1-}"
    fi

    local _longOpts
    while [[ \
        -n "${1-}" \
        && "${1-}" =~ ^--[a-zA-Z0-9_][a-zA-Z0-9_=\"-][a-zA-Z0-9_=\"-]* \
    ]]
    do
       _longOpts="${_longOpts-} ${1-}"
       shift
    done
    local -A __opts=$( _getOptsArray ${_longOpts-} )

    local _context=''
    if [[ "${1-}" ]]; then
        _context="${1-}"
        shift
        if [[ \
            -d "${_context-}" \
            && "${_context-}" =~ ^[^/] \
        ]]; then
            _context=$(cd ${_context-} && pwd)
        fi
    else
        _context=$( \
            ${_RECKER_ABS-} _comp dockerfile-and-images-name \
            | ${_PERCOL-} --prompt='Recker run' \
        )
    fi

    if [[ ! "${_context-}" ]]; then
        _warn "specify context directory or image name..."
        return 1
    fi
    local _howMany=(${_context-})
    if [[ ${#_howMany[@]} -gt 1 ]]; then
        _warn "too much target to run..."
        return 1
    fi

    local _maintainerName="${USER-}"
    [[ -n "${_CONF[DOCKER_MAINTAINER_NAME]-}" ]] \
        && _maintainerName="${_CONF[DOCKER_MAINTAINER_NAME]}"
    local _imgName="${_context-}"
    local _imgToExec=''
    local _isUnderRecker=0
    local _imgConfigFile=''
    local -A _ICONF
    if [[ -d "${_imgName-}" ]]; then
        _imgName="${_imgName##*/}"
        _imgToExec="${_maintainerName-}/${_imgName-}"
        _isUnderRecker=1
        _imgConfigFile="${_context-}/config.sh"
        if [[ -r "${_imgConfigFile-}" ]]; then
            source <(
                grep '^[A-Z0-9_]\{1,\}=.*$' "${_imgConfigFile-}" \
                | grep -v '^SET[[:blank:]]' \
                | sed -e 's|^\([A-Z0-9_]\{1,\}\)\(=.*\)$|_ICONF[\1]\2|' \
            )
            local _envs=$(
                grep '^SET[[:blank:]]' "${_imgConfigFile-}" \
                | sed \
                    -e 's|^SET[[:blank:]]\{1,\}\([^=[:blank:]]\{1,\}\)="\(.*\)"$|\1=\2|;' \
                    -e 's| |__|g'
            )
            _envs=$(
                echo "${_envs-}" \
                | grep -v '^$' \
                | sed -e 's|^|-e |' \
                | tr '\n' ' ' \
            )
        fi
    else
        _imgToExec="${_imgName-}"
        _imgName="${_imgName//\//_}"
        _imgName="${_imgName//:/_}"
    fi

    if \
        ${_RECKER_ABS-} _comp images-name \
        | grep -q "${_imgToExec-}" >& /dev/null
    then
        :
    else
        _warn "no such image built or available..."
        return 1
    fi

    local _otherOptions
    [[ "${_ICONF[SWAPPY]-}" ]] \
        && _otherOptions+=" --memory-swappiness=${_ICONF[SWAPPY]-}"
    [[ "${_ICONF[OOMK_CANCEL]-}" ]] \
        && _otherOptions+=" --oom-kill-disable=true"
    local _capability
    [[ "${_ICONF[PRIVILEGED]-}" || "${__opts[privileged]-}" ]] \
        && _capability+=" --privileged"
    [[ "${_ICONF[CAPABILITY]-}" ]] \
        && _capability=${_ICONF[CAPABILITY]-}
    _otherOptions+=" ${_capability-}"

    local _containerName="${_imgName-}"
    local _regexGetDockerCName='s|^\([^[:blank:]]\{1,\}\)[[:blank:]].*[[:blank:]]\([^[:blank:]]\{1,\}\)[[:blank:]]\{1,\}$|\2|'
    local _count=0
    while true
    do
        if ${_DOCKER-} ps -a \
            | tail -n +2 \
            | sed -e "$_regexGetDockerCName" \
            | grep -q "^${_containerName-}$" >& /dev/null
        then
            :
        else
            break
        fi
        _count=$(( _count + 1 ))
        _containerName="${_imgName-}_${_count}"
    done

    local _executable=''
    local _entryPoint=$( \
        ${_DOCKER-} inspect \
            --format='{{range .Config.Entrypoint }}{{println .}}{{end}}' \
            "${_imgToExec-}" \
    )
    if [[ ! "${_entryPoint-}" ]]; then
        _executable="${_CONF[DOCKER_ENTRY_EXECUTABLE]-}"
        [[ ${_isUnderRecker-} ]] \
            && _executable="${_CONF[DOCKER_SERVICE_ENTRYPOINT]-}"
        [[ -n "${_ICONF[EXEC]-}" ]] \
            && _executable="${_ICONF[EXEC]-}"
        [[ "$@" ]] \
            && _executable="$@"
    else
        [[ -n "${_ICONF[EXEC]-}" ]] \
            && _executable="${_ICONF[EXEC]-}"
        [[ "$@" ]] \
            && _executable="$@"
    fi

    function __addToBeCleaned () {
        echo "$@" >> ${_context-}/.tobecleaned
    }

    local _ports=''
    local _volumes=''
    local _links=''
    if [[ "${_ICONF[PORTS]-}" ]]; then
        for i in ${_ICONF[PORTS]-}
        do
            _ports+="-p $i "
        done
    fi
    if [[ "${_ICONF[LINKS]-}" ]]; then
        for i in ${_ICONF[LINKS]-}
        do
            _links+="--link $i:$i "
        done
    fi
    local _contextLastElem="${_context##*/}"
    local _baseDir="${_CONF[DIR_DOCKER_BASE_GLOBAL]-}/${_CONF[DIR_DOCKER_VOLUMES]-}/${_contextLastElem-}"
    [[ $(_getEuid) -ne 0 ]] \
        && _baseDir="${_CONF[DIR_DOCKER_VOLUMES_THISUSER]-}/${_contextLastElem-}"
    local _localDir=''
    local _tempVolumes="${_ICONF[VOLUMES]-}"
    grep -q \
        -e '^[^#]\{0,\}_cSetScriptFor1stRuntime' \
        "${_context-}/container_build.sh" \
            && _tempVolumes+=' /var/recker/log'
    if [[ "${_tempVolumes-}" ]]; then
        for i in ${_tempVolumes-}
        do
            _localDir="${_baseDir-}$i"
            if _makeSureDir ${_localDir-}; then
                __addToBeCleaned "VOLUME: ${_localDir-}"
            else
                _warn "Can't make directory : ${_localDir-}"
                return 1
            fi
            _volumes+="-v ${_localDir-}:$i:rw "
        done
    fi

    function __findUnusedPortFrom() {
        local _cur=${1-}
        local _listeningPorts=":$( \
            ss -ant \
            | tail -n +2 \
            | sed -e 's|^.*:\([0-9]\{1,\}\)[[:blank:]].*$|\1|' \
            | sort -n \
            | uniq \
            | tr '\n' ':' \
        )"
        while true
        do
            [[ $_listeningPorts =~ :${_cur-}: ]] \
                || break
            _cur=$(( _cur + 1 ))
            [[ ${_cur-} -gt 65535 ]] \
                && return 1
        done
        echo "${_cur-}"
        return 0
    }
    local _result
    if [[ "${_ICONF[AUTOMAP_PORT_HTTP]-}" ]]; then
        _result=$( __findUnusedPortFrom ${_CONF[AUTOMAP_PORT_HTTP_FROM]-} )
        _mention "HTTP port auto-mapped to: ${_result-}"
        _ports="${_ports-} -p ${_result-}:80 "
        _envs="${_envs-} -e AUTOMAP_PORT_HTTP=\"${_result-}\""
    fi
    if [[ "${_ICONF[AUTOMAP_PORT_SSH]-}" ]]; then
        _result=$( __findUnusedPortFrom ${_CONF[AUTOMAP_PORT_SSH_FROM]-} )
        _mention " SSH port auto-mapped to: ${_result-}"
        _ports="${_ports-} -p ${_result-}:22 "
        _envs="${_envs-} -e AUTOMAP_PORT_SSH=\"${_result-}\""
    fi
    if [[ "${_ICONF[RUN_AS_SERVICE]-}" -eq 1 ]]; then
        [[ "${_switchFgBg-}" != "${_CONF[DOCKER_RUN_SWITCH_BG]-}" ]] \
            && _mention 'Changed mode to background because of declaration RUN_AS_SERVICE'
        _switchFgBg="${_CONF[DOCKER_RUN_SWITCH_BG]-}"
    fi

    [[ "${DEBUG-}" ]] && cat <<_EOF_
    ${_DOCKER-} run \
        ${_switchFgBg-} \
        --add-host="dockerhost:$(_getHostIPv4)" \
        -e DOCKER_HOST_IP="$(_getHostIPv4)" \
        --name="${_containerName-}" \
        ${_envs-} \
        ${_ports-} \
        ${_links-} \
        ${_volumes-} \
        ${_otherOptions-} \
        "${_imgToExec-}" \
        ${_executable-}
_EOF_

    [[ "${DEBUG-}" ]] || (
        cd ${_context-}
        [[ "${_CONF[COMMAND_PRE_RUN]-}" ]] \
            && bash -c "${_CONF[COMMAND_PRE_RUN]-}"
        [[ "${_ICONF[COMMAND_PRE_RUN]-}" ]] \
            && bash -c "${_ICONF[COMMAND_PRE_RUN]-}"

        ${_DOCKER-} run \
            ${_switchFgBg-} \
            --add-host="dockerhost:$(_getHostIPv4)" \
            -e DOCKER_HOST_IP="$(_getHostIPv4)" \
            -e CURRENT_DIR="$(pwd)" \
            --name="${_containerName-}" \
            ${_envs-} \
            ${_ports-} \
            ${_links-} \
            ${_volumes-} \
            ${_otherOptions-} \
            "${_imgToExec-}" \
            ${_executable-}

        if
            [[ \
                $(${_DOCKER-} exec "${_containerName-}" \
                    grep -v '^$' \
                        /var/recker/usr/container_runonce.sh 2> /dev/null \
                | grep -v '^#' \
                | wc -l) \
                -gt 0 \
            ]]
        then
            _mention "Waiting until container's 1st time preparation script finishes jobs..."
            local _cc=0
            while true ;
            do
                ${_DOCKER-} exec "${_containerName-}" /usr/local/bin/is_preparation_done \
                    && break
                sleep 10
                _cc=$(($_cc + 10))
                if [[ ${_cc-} -ge 60 ]]; then
                    _cc=0
                    echo -n o
                fi
            done
            echo ''
            echo '...done.'
        fi

        cd ${_context-}
        [[ "${_CONF[COMMAND_POST_RUN]-}" ]] \
            && bash -c "${_CONF[COMMAND_POST_RUN]-}"
        [[ "${_ICONF[COMMAND_POST_RUN]-}" ]] \
            && bash -c "${_ICONF[COMMAND_POST_RUN]-}"
    )
}

function _recker-run-fg() {
    _recker-RUN-FGorBG fg "$@"
}

function _recker-run-bg() {
    _recker-RUN-FGorBG bg "$@"
}

function _recker-run() {
    _recker-run-fg "$@"
}

#function _recker-exec-all() {
#    local -A _ICONF
#    if [[ -d "${_imgName-}" ]]; then
#        _imgName="${_imgName##*/}"
#        _imgToExec="${_maintainerName-}/${_imgName-}"
#        _isUnderRecker=1
#        _imgConfigFile="${_context-}/config.sh"
#        if [[ -r "${_imgConfigFile-}" ]]; then
#            source <( \
#                grep '^[A-Z0-9_]\{1,\}=.*$' "${_imgConfigFile-}" \
#                | grep -v '^SET[[:blank:]]' \
#                | sed -e 's|^\([A-Z0-9_]\{1,\}\)\(=.*\)$|_ICONF[\1]\2|' \
#        fi
#    fi
#}

###
### recker implode
###
function _recker-implode() {
    if ! which shar >/dev/null ; then
        _die 'There is not `shar` command. Install sharutils, please.'
    fi

    local _longOpts
    while [[ \
        -n "${1-}" \
        && "${1-}" =~ ^--[a-zA-Z0-9_][a-zA-Z0-9_=\"-][a-zA-Z0-9_=\"-]* \
    ]]
    do
       _longOpts="${_longOpts-} ${1-}"
       shift
    done
    local -A __opts=$( _getOptsArray ${_longOpts-} )

    local _context=''
    if [[ "${1-}" ]]; then
        _context="${1-}"
        shift
        if [[ \
            -d "${_context-}" \
            && "${_context-}" =~ ^[^/] \
        ]]; then
            _context=$(cd ${_context-} && pwd)
        fi
    else
        _context=$( \
            ${_RECKER_ABS-} _comp dockerfiles \
            | ${_PERCOL-} --prompt='Recker implode' \
        )
    fi

    if [[ ! "${_context-}" ]]; then
        _warn "specify context directory..."
        return 1
    fi
    local _howMany=(${_context-})
    if [[ ${#_howMany[@]} -gt 1 ]]; then
        _warn "too much target to implode..."
        return 1
    fi
    if [[ ! -d "${_context-}" ]]; then
        _warn "no such context directory..."
        return 1
    fi

    local _targetFile="${1-}"
    if [[ -z ${_targetFile-} ]]; then
        _die "Specify target file name for implosion..."
    fi
    shift

    local -A _ICONF
    local -A _p
    _p['_Z']='Z'
    local _imgConfigFile="${_context-}/config.sh"

    [[ ! "${DEBUG-}" && -f ${_context-}/.tobecleaned ]] \
         && _recker-clean \
             --units="FILE,DIR" \
             ${_context-}

    local _dirToShar=$( mktemp -d )
    for _i in \
        Dockerfile config.sh container_build.sh pre_build.sh post_build.sh \
        _upload
    do
        [[ ! -r ${_context-}/${_i-} ]] \
            && continue
        if [[ -d ${_context-}/${_i-} ]]; then
            cp -r ${_context-}/${_i-} ${_dirToShar-}/
            continue
        fi
        cp ${_context-}/${_i-} ${_dirToShar-}/
    done

    [[ -f ${_dirToShar}/config.sh ]] \
        && sed -i \
            -e 's|^SET[[:blank:]]\{1,\}\([^[:blank:]=]\{1,\}\)=\([^=]\{0,\}\)$|SET \1=|' \
                ${_dirToShar-}/config.sh

    local _implosionTempFile=$( mktemp )
    sed -e "s|%%_VERSION%%|${_VERSION-}|" <<'_EOF_' > ${_implosionTempFile-}
#!/bin/bash
RECKER=%%_VERSION%%
if [[ ! ${RECKER_EXPLODE-} ]]; then
   echo -e "\e[31m$@\e[m This is a template file for recker. Plase call via recker." >&2
   exit 1
fi
#__BEGIN__SHAR__
_EOF_
    (
        cd ${_dirToShar}
        shar --no-i18n --no-md5-digest * >> ${_implosionTempFile-}
    )

    local _isSaved=0
    if [[ -f "${_targetFile-}" ]]; then
        mv ${_targetFile-} ${_targetFile-}.save \
            && _isSaved=1
    fi
    if ! mv ${_implosionTempFile-} ${_targetFile-}; then
        _warn "Cannot write: ${_targetFile-} "
        [[ ${_isSaved-} ]] \
            && mv ${_targetFile-}.save ${_targetFile-}
    else
        _mention "Implosion complete: ${_targetFile-}"
    fi

    [[ -d ${_dirToShar-} ]] \
        && /bin/rm -rf ${_dirToShar-}
    [[ -f ${_implosionFile-} ]] \
        && /bin/rm ${_implosionTempFile-}
}

function _recker-explode() {
    local _cmd
    for _cmd in shar uudecode dialog
    do
        if ! which ${_cmd} >/dev/null 2>/dev/null ; then
            _die "There is not '${_cmd}' command. Install it, please."
        fi
    done

    local _longOpts
    while [[ \
        -n "${1-}" \
        && "${1-}" =~ ^--[a-zA-Z0-9_][a-zA-Z0-9_=\"-][a-zA-Z0-9_=\"-]* \
    ]]
    do
       _longOpts="${_longOpts-} ${1-}"
       shift
    done
    local -A __opts=$( _getOptsArray ${_longOpts-} )

    local _templateFilename="${1-}"
    if [[ -z "${_templateFilename-}" ]]; then
        _warn "specify template file name..."
        return 1
    fi
    [[ ! -f "${_templateFilename-}" ]] \
        && _die "No such template file: ${_templateFilename-}"
    shift

    local __version
    __version=$( \
        grep '^RECKER=[0-9\.]\{1,\}$' ${_templateFilename-} \
            | head -1 \
            | sed 's|^RECKER=\([0-9]\{1,\}\)$|\1|'
    )
    [[ -z ${__version-} ]] \
        && __version=0

    local __sharLine='#__BEGIN__SHAR__'
    if \
        [[ ${__version-} == '0' ]] \
        && ! grep -q "^${__sharLine-}" ${_templateFilename-} \
    ; then
        _die "Unknown data format: ${_templateFilename-}"
    fi

    local _context="${1-}"
    if [[ -z "${_context-}" ]]; then
        _warn "specify target directory name to explode the template..."
        return 1
    fi
    [[ -d "${_context-}" ]] \
        && _die "Context directory already exist: ${_context-}"
    shift

    local _dirToUnshar=$( mktemp -d )
    sed -n "/^${__sharLine-}/,\$ p" ${_templateFilename-} \
        | tail -n +2 \
        | ( cd ${_dirToUnshar-}  && /bin/bash )

    local _variableNames=$( \
        grep '^SET[[:blank:]]\{1,\}\([^[:blank:]=]\{1,\}\)=\([^=]\{0,\}\)$' \
                ${_dirToUnshar-}/config.sh \
            | sed 's|^SET[[:blank:]]\{1,\}\([^[:blank:]=]\{1,\}\)=\([^ =]\{0,\}\)$|\1|'
    )

    local _longestName
    local _longestLength=0
    local i
    for i in ${_variableNames}
    do
        if [[ ${_longestLength-} -lt ${#i} ]]; then
            _longestLength=${#i}
            _longestName=${i}
        fi
    done

    local _undefinedString='__undefined__'
    local _widgetString
    local _c=0
    for i in ${_variableNames}
    do
        (( _c++ ))
        _widgetString+="\
${i} \
    ${_c} 1 \
    ${_undefinedString} \
        ${_c} ${_longestLength} \
        ${_longestLength-} 256 \
"
    done
    _widgetString=$( echo ${_widgetString} | sed 's/  / /g' )

    local _dialogTitle='Input variables for new container:'
    local _dialogFormOpt="\
$(( _c+9 )) \
$(( _longestLength+_longestLength )) \
$(( _c+1 )) \
"

    local _vars=$( mktemp )
    dialog \
        --trim \
        --stdout \
        --form \
            "${_dialogTitle}" \
            ${_dialogFormOpt} \
            ${_widgetString} \
        > ${_vars-}

    local _value
    _c=0
    for i in ${_variableNames}
    do
        (( _c++ ))
        _value=$( sed -n "${_c} p" ${_vars-} )
        [[ ${_value} = ${_undefinedString-} ]] \
            && _value=''
        _value=${_value//|/\|}
        sed -i \
            -e "s|^\(SET[[:blank:]]\{1,\}${i}=\).*$|\1${_value}|" \
            ${_dirToUnshar-}/config.sh
    done

    if [[ -d "${_context-}" ]]; then
        _warn "Context directory already exist: ${_context-}"
    else
        if mv ${_dirToUnshar} ${_context}; then
            _mention "Explosion complete: ${_context-}"
        else
            _warn "Cannot make new context directory: ${_context-}"
        fi
    fi

    [[ -d ${_dirToUnshar-} ]] \
        && /bin/rm -rf ${_dirToUnshar}
    [[ -f ${_vars-} ]] \
        && /bin/rm -f ${_vars}
}

function _recker-rmi() {
    local cids=''
    local opt=''
    if [[ "${1-}" = '-a' ]]; then
        opt='-a'
        shift
    fi
    if [[ "$@" ]]; then
        cids="$@"
    else
        cids=$( \
            echo "$( \
                ${_DOCKER-} images $opt -t 2> /dev/null \
                    | sed -e 's|^|:|' \
                    | $_PERCOL  --prompt='Recker rmi' \
                )" \
            | tac \
            | sed -e 's|^:[^0-9a-z]\{1,\}\([0-9a-z]\{1,\}\) .*$|\1|' \
        )
        #cids=$( echo "$( \
        #    ${_DOCKER-} images $opt \
        #    | $_PERCOL  --prompt='Recker rmi' \
        #    )" | awk '{print $3}' )
    fi
    if [[ ! "${cids-}" ]]; then
        _warn "specify image ids..."
        return 1
    fi
    _mention "Removing docker images: $cids..."
    local _i=''
    for i in $cids
    do
        ${_DOCKER-} rmi "$i"
    done
}

function _recker-rmi-a() {
    _recker-rmi '-a'
}

function _recker-STOPorKILLorRM() {
    local cid=''
    local action=''
    local opt=''

    if [[ "${1-}" =~ ^(stop|kill|rm)$ ]]; then
        action="$1"
        shift
    else
        _die "[Error] Unknown action? ${1-}"
    fi
    if [[ "${1-}" = '-a' ]]; then
        opt='-a'
        shift
    fi
    if [[ "$@" ]]; then
        cid="$@"
    else
        cid=$(echo "$( ${_DOCKER-} ps $opt \
            | $_PERCOL --prompt=Recker\ ${action-} )" | awk '{print $1}')
    fi
    if [[ ! "${cid-}" ]]; then
        _warn "specify container id..."
        return 1
    fi
    _mention "Started to ${action} docker containers: ${cid}..."
    ${_DOCKER-} $action $cid
}
function _recker-stop() {
    _recker-STOPorKILLorRM stop "$@"
}
function _recker-stop-a() {
    _recker-STOPorKILLorRM stop -a "$@"
}
function _recker-kill() {
    _recker-STOPorKILLorRM kill "$@"
}
function _recker-kill-a() {
    _recker-STOPorKILLorRM kill -a "$@"
}
function _recker-rm() {
    _recker-STOPorKILLorRM rm -a "$@"
}

function _recker-STOPorKILL-rm() {
    local cid=''
    local action=''
    local opt=''

    if [[ "${1-}" =~ ^(stop|kill)$ ]]; then
        action="$1"
        shift
    else
        _die "[Error] Unknown action? ${1-}"
    fi
    if [[ "${1-}" = '-a' ]]; then
        opt='-a'
        shift
    fi
    if [[ "$@" ]]; then
        cid="$@"
    else
        cid=$(echo "$( ${_DOCKER-} ps $opt \
            | $_PERCOL --prompt=Recker\ ${action-}-rm )" | awk '{print $1}')
    fi
    if [[ ! "${cid-}" ]]; then
        _warn "specify container id..."
        return 1
    fi
    _mention "Started to ${action} and remove docker containers: ${cid}..."
    ( ${_DOCKER-} $action $cid && ${_DOCKER-} rm $cid )
}
function _recker-stop-rm() {
    _recker-STOPorKILL-rm stop "$@"
}
function _recker-stop-rm-a() {
    _recker-STOPorKILL-rm stop -a "$@"
}
function _recker-kill-rm() {
    _recker-STOPorKILL-rm kill "$@"
}
function _recker-kill-rm-a() {
    _recker-STOPorKILL-rm kill -a "$@"
}
function _recker-STOPorKILLorRMorDESTROY-all-containers() {
    local cid=''
    local action=''
    local opt=''

    if [[ "${1-}" =~ ^(stop|kill)$ ]]; then
        action="$1"
        shift
        cid=$( ${_DOCKER-} ps -q )
        [[ ! "${cid-}" ]] && return
        _mention "Started to ${action} docker containers: ${cid}..."
        ${_DOCKER-} $action $cid
    elif [[ "${1-}" = 'rm' ]]; then
        action="$1"
        shift
        cid=$( ${_DOCKER-} ps -a --filter=status=exit -q )
        [[ ! "${cid-}" ]] && return
        _mention "Started to ${action} docker containers: ${cid}..."
        ${_DOCKER-} $action $cid
    elif [[ "${1-}" = 'destroy' ]]; then
        action="$1"
        shift
        _mention "Started to stop and rm all docker containers"
        ( \
            ${_DOCKER-} stop \
                $( \
                    ${_DOCKER-} ps -a \
                        --filter=status=running \
                        --filter=status=paused \
                        --filter=status=restarting \
                        -q \
                ) \
            && ${_DOCKER-} rm \
                $( \
                    ${_DOCKER-} ps -a \
                        --filter=status=exit \
                        -q \
                ) \
        )
    else
        _die "[Error] Unknown action? ${1-}"
    fi
}
function _recker-stop-all-containers() {
    _recker-STOPorKILLorRMorDESTROY-all-containers stop
}
function _recker-kill-all-containers() {
    _recker-STOPorKILLorRMorDESTROY-all-containers kill
}
function _recker-rm-all-containers() {
    _recker-STOPorKILLorRMorDESTROY-all-containers rm
}
function _recker-destroy-all-containers() {
    _recker-STOPorKILLorRMorDESTROY-all-containers destroy
}

function _recker-enter() {
    local _cid=''

    if [[ "${1-}" ]]; then
        _cid="${1-}"
    else
        _cid=$(echo "$( ${_DOCKER-} ps \
            | $_PERCOL --prompt='Recker enter' )" | awk '{print $1}')
    fi
    if [[ ! "${_cid-}" ]]; then
        _warn "specify container id..."
        return 1
    fi
    _mention "entering container: ${_cid-}..."
    ${_DOCKER-} exec -it $_cid ${_CONF[DOCKER_ENTERING_COMMAND]}
}

function _recker-top() {
    local _cid=''

    if [[ "${1-}" ]]; then
        _cid="${1-}"
    else
        _cid=$(echo "$( ${_DOCKER-} ps \
            | $_PERCOL --prompt='Recker top' )" | awk '{print $1}')
    fi
    if [[ ! "${_cid-}" ]]; then
        _warn "specify container id..."
        return 1
    fi
    ${_DOCKER-} top $_cid
}

function _recker-select-images() {
    local _opt=''
    if [[ "${1-}" = '-a' ]]; then
        _opt='-at'
        shift
    fi
    local _cid=''
    if [[ "$@" ]]; then
        _cid="$@"
    else
        if [[ "${_opt-}" =~ t ]]; then
            _cid=$(
                echo "$( \
                    ${_DOCKER-} images ${_opt-} 2> /dev/null \
                    | sed -e 's|^|:|' \
                    | $_PERCOL --prompt='Recker select-images' \
                )" \
                | tac \
                | sed -e 's|^:[^0-9a-z]\{1,\}\([0-9a-z]\{1,\}\) .*$|\1|' \
                | tr '\n' ' ' \
            )
        else
            _cid=$(
                echo "$( \
                    ${_DOCKER-} images ${_opt-} \
                    | $_PERCOL --prompt='Recker select-images' \
                )" \
                | awk '{print $1}' \
                | tr '\n' ' ' \
            )
        fi
    fi
    if [[ ! "${_cid-}" ]]; then
        _warn "specify image namr or id..."
        return 1
    fi
    echo "${_cid-}"
}
function _recker-select-images-a() {
    _recker-select-images -a
}

function _recker-select-containers() {
    local _opt=''
    if [[ "${1-}" = '-a' ]]; then
        _opt='-a'
        shift
    fi
    local _cid=''
    if [[ "$@" ]]; then
        _cid="$@"
    else
        _cid=$(echo "$( ${_DOCKER-} ps ${_opt-} \
            | $_PERCOL --prompt='Recker select-containers' )" \
            | awk '{print $1}' \
            | tr '\n' ' ' \
        )
    fi
    if [[ ! "${_cid-}" ]]; then
        _warn "specify container id..."
        return 1
    fi
    echo "${_cid-}"
}
function _recker-select-containers-a() {
    _recker-select-containers -a
}

function __getContainerIPInfo() {
    local _target="${1-}"
    if [[ -z "${_target-}" ]]; then
        _warn 'specify container name...'
        return 1
    fi
    local _inspect=$( \
        docker inspect \
            --format="${_QUERIES[_DOCKER_INSPECT_IP]-}" \
            ${_target-} \
            | tr -d '[:blank:]' \
    )
    echo "${_inspect-}"
    return
}
function _recker-get-container-ip() {
    local _target="${1-}"
    if [[ -z "${_target-}" ]]; then
        _warn 'specify container name...'
        return 1
    fi
    local _result=$( __getContainerIPInfo ${_target-} )
    echo "${_result-}"
    return
}

function __confirmAlivePortSMTP() {
    local _ip="${1-}"
    if [[ -z "${_ip-}" ]]; then
        _warn 'specify IP addr...'
        return 1
    fi
    local _port='25'
    local _fqdn=$(
        {
            exec 3<> /dev/tcp/${_ip-}/${_port-}
            echo -e 'HELO example.com\nQUIT\n' >&3
            grep '^250 ' <&3 \
                | sed \
                        -e 's|^[0-9]\{1,\}[[:blank:]]\{1,\}||' \
                        -e 's|[^0-9a-zA-Z.-]||g'
        } 2> /dev/null
    )
    [[ -z "${_fqdn-}" ]] && return 1
    echo "${_fqdn-}"
}
function _recker-get-containers-fqdn-and-port-smtp() {
    local _opt
    if [[ "${1-}" =~ ^-[p]$ ]]; then
        _opt="${1#-}"
        shift
    fi
    local _result=$( _recker-get-containers-names )
    [[ "${_result-}" ]] || return
    local _fqdn
    local _ip
    local i
    [[ "${_opt-}" = 'p' ]] \
        && cat /dev/null > "${_CONF[POSTFIX_TRANSPORT]-}"
    for i in ${_result-}
    do
        _ip=$( _recker-get-container-ip $i )
        _fqdn=$( __confirmAlivePortSMTP $_ip )
        [[ "${_fqdn-}" ]] || continue
        case "${_opt-}" in
            p)
                echo "${_fqdn-} smtp:${_ip-}" \
                    >> "${_CONF[POSTFIX_TRANSPORT]-}"
                ;;
            *)
                echo "${i-}:${_fqdn-}:${_ip-}"
                ;;
        esac
    done
    [[ "${_opt-}" = 'p' ]] \
        && $_POSTMAP "${_CONF[POSTFIX_TRANSPORT]-}"
}

function __getContainerPortsInfo() {
    local _target="${1-}"
    if [[ -z "${_target-}" ]]; then
        _warn 'specify container name...'
        return 1
    fi
    local _inspect=$( \
        docker inspect \
            --format="${_QUERIES[_DOCKER_INSPECT_PORTS]-}" \
            ${_target-} \
            | tr -s '[:space:]' ' ' \
    )
    echo "${_inspect-}"
    return
}
function _recker-get-container-ports() {
    local _target="${1-}"
    if [[ -z "${_target-}" ]]; then
        _warn 'specify container name...'
        return 1
    fi
    local _result=$( __getContainerPortsInfo ${_target-} )
    echo "${_result-}"
    return
}
function _recker-get-container-port-ANYTCP() {
    local _target="${1-}"
    if [[ -z "${_target-}" ]]; then
        _warn 'specify container name...'
        return 1
    fi
    shift
    local _targetPort="${1-}"
    if [[ -z "${_targetPort-}" ]]; then
        _warn 'specify port number...'
        return 1
    fi
    shift
    local _ports=$( __getContainerPortsInfo ${_target-} )
    local _result=''
    if [[ -n "${_ports-}" ]]; then
        _result=$( \
            echo "${_ports-}" \
            | sed -e 's| |\n|g' \
            | grep "^${_targetPort-}/tcp:" \
        )
        [[ -n "${_result-}" ]] && _result=${_result##*:}
    fi
    [[ -z "${_result-}" ]] && return 1
    echo "${_result-}"
}
function _recker-get-container-port-http() {
    [[ -z "${1-}" ]] && return 1
    _recker-get-container-port-ANYTCP $1 80
}
function _recker-get-container-port-ssh() {
    [[ -z "${1-}" ]] && return 1
    _recker-get-container-port-ANYTCP $1 22
}

function _recker-get-containers-names() {
    local _result=$( \
        ${_DOCKER-} ps \
        | tail -n +2 \
        | sed -e "${_SEDEXP[GET_DOCKER_CNAME]-}" \
        | tr '\n' ' ' \
    )
    echo "${_result-}"
    return
}

function _recker-get-containers-names-and-port-http() {
    local _opt
    if [[ "${1-}" =~ ^-[snap]$ ]]; then
        _opt="${1#-}"
        shift
    fi
    local _result=$( _recker-get-containers-names )
    [[ "${_result-}" ]] || return
    local _port
    local i
    for i in ${_result-}
    do
        _port=$( _recker-get-container-port-http $i )
        [[ "${_port-}" ]] || continue
        case "${_opt-}" in
            s)
                echo "export CONTAINER_HTTP_${i^^}=${_port-}"
                ;;
            a)
                echo "SetEnv PORT_FOR_${i^^} ${_port-}"
                ;;
            n)
                echo "set \$url_for_${i,,} http://localhost:${_port-}/;"
                ;;
            p)
                mkdir -p /etc/nginx/recker
                echo "proxy_pass http://localhost:${_port-};" \
                    > /etc/nginx/recker/${i,,}
                ;;
            *)
                echo "$i:${_port-}"
                ;;
        esac
    done
}

###
### some helper commands
###

function _recker-install-percol() {
    if ! which $_PERCOL >& /dev/null ; then
        :
    else
        _mention "$_PERCOL is already available"
        exit 1
    fi
    if [[ $(_getEuid) -ne 0 ]]; then
        _die 'Insufficient privileges. You must be root or execute me by sudo'
    fi

    if [[ \
        'Linux' != "$(_getOSName)" \
        || ! "$(_getDistName)" =~ ^(redhat|fedora|centos)$ \
    ]]; then
        _die ":( Sorry, I don't know how to install percol to your os..."
    fi

    local i
    i="$( _sureYesOrNo 'You really want to install percol?' )"
    if [[ "${i-}" = 'y' ]]; then
        yum -y install python-setuptools && \
        easy_install pip && \
        pip install percol
    fi
}

###
### bash completion
###

mapfile _BASH_COMPLETION <<'_EOF_'
# bash completion for recker ( independent from bash_completion )
function _recker() {
    local _RECKER='%%RECKER_ABS%%'
    local cur
    cur=${COMP_WORDS[COMP_CWORD]}
    local _action=${COMP_WORDS[COMP_CWORD-1]}
    local _list

    COMPREPLY=()
    if [[ $COMP_CWORD -le 1 ]]; then
        _list=$( $_RECKER _comp commands )
        COMPREPLY=( $(compgen -W "${_list-}" $cur) )
        return 0
    fi

    case "${_action-}" in
        stop|kill|stop-rm|kill-rm)
            _list=$( $_RECKER _comp ps )
            ;;
        stop-a|kill-a|stop-rm-a|kill-rm-a)
            _list=$( $_RECKER _comp ps-a )
            ;;
        rmi)
            _list=$( $_RECKER _comp images )
            ;;
        rmi-a)
            _list=$( $_RECKER _comp images-a )
            ;;
        build|clean|implode|explode)
            _list=$( $_RECKER _comp dockerfiles )
            ;;
        run|run-fg|run-bg)
            _list=$( $_RECKER _comp dockerfile-and-images-name )
            ;;
        enter)
            _list=$( $_RECKER _comp ps )
            ;;
        top)
            _list=$( $_RECKER _comp ps )
            ;;
        get-container-ip|get-container-ports|get-container-port-http|get-container-port-ssh)
            _list=$( $_RECKER _comp ps )
            ;;
        select-images)
            _list=$( $_RECKER _comp images )
            ;;
        select-containers)
            _list=$( $_RECKER _comp ps )
            ;;
        select-images-a)
            _list=$( $_RECKER _comp images-a )
            ;;
        select-containers-a)
            _list=$( $_RECKER _comp ps-a )
            ;;
    esac
    COMPREPLY=( $(compgen -W "${_list-}" $cur) )
}
complete -p | grep -q ' recker$' >& /dev/null \
    && complete -r recker
complete -o default -o bashdefault -F _recker recker
_EOF_

function _recker-bashcompletion() {
    printf %s "${_BASH_COMPLETION[@]//%%RECKER_ABS%%/$_RECKER_ABS}"
}
# source <(recker bashcompletion)

function _recker-_print_container_lib_sh() {
    echo "$( eval "printf %s \"\${_B_CONTAINER_LIB_SH[@]}\"" )"
}

function _recker-_comp() {
    local i
    local _action="${1-}"
    [[ "${_action-}" ]] || _die 'whats?'
    shift

    local _regexGetDockerCidName="${_SEDEXP[GET_DOCKER_CID_NAME]-}"
    local _regexGetDockerImageName='s|^\([^[:blank:]]\{1,\}\)[[:blank:]]\{1,\}\([^[:blank:]]\{1,\}\)[[:blank:]]\{1,\}\([^[:blank:]]\{1,\}\).*$|\1:\2|'
    local _regexGetDockerImageNameId='s|^\([^[:blank:]]\{1,\}\)[[:blank:]]\{1,\}\([^[:blank:]]\{1,\}\)[[:blank:]]\{1,\}\([^[:blank:]]\{1,\}\).*$|\1:\2 \3|'
    local _regexGetDockerImageNameIdAll='s|^[^[:blank:]]\{1,\}[[:blank:]]\{1,\}[^[:blank:]]\{1,\}[[:blank:]]\{1,\}\([^[:blank:]]\{1,\}\).*$|\1|'

    function __getDockerImageNameId() {
        echo $( \
            ${_DOCKER-} images \
            | tail -n +2 \
            | grep -v '<none>' \
            | sed -e "$_regexGetDockerImageNameId" \
        )
    }

    case "${_action-}" in
        dockerfiles)
            [[ \
                $(_getEuid) -ne 0 \
                && -d "${_CONF[DIR_DOCKER_DOCKERFILES_THISUSER]-}" \
            ]] \
                && find "${_CONF[DIR_DOCKER_DOCKERFILES_THISUSER]-}" \
                    -mindepth 2 -maxdepth 2 -name 'Dockerfile' -type f \
                | sed -e 's|/Dockerfile$||'
            [[ \
                -d "${_CONF[DIR_DOCKER_BASE_GLOBAL]-}/${_CONF[DIR_DOCKER_DOCKERFILES]-}" \
                && -r "${_CONF[DIR_DOCKER_BASE_GLOBAL]-}/${_CONF[DIR_DOCKER_DOCKERFILES]-}" \
            ]] \
                && find "${_CONF[DIR_DOCKER_BASE_GLOBAL]-}/${_CONF[DIR_DOCKER_DOCKERFILES]-}" \
                    -mindepth 2 -maxdepth 2 -name 'Dockerfile' -type f \
                | sed -e 's|/Dockerfile$||'
            ;;
        commands)
            for i in "${_SUB_COMMANDS[@]}";
            do
                [[ "${i-}" =~ ^_ ]] || echo "${i-}"
            done
            ;;
        ps)
            echo $( \
                ${_DOCKER-} ps \
                | tail -n +2 \
                | sed -e "$_regexGetDockerCidName" \
            )
            ;;
        ps-a)
            echo $( \
                ${_DOCKER-} ps -a \
                | tail -n +2 \
                | sed -e "$_regexGetDockerCidName" \
            )
            ;;
        images)
            __getDockerImageNameId
            ;;
        images-a)
            __getDockerImageNameId
            echo $( \
                ${_DOCKER-} images -a \
                | tail -n +2 \
                | grep '<none>' \
                | sed -e "$_regexGetDockerImageNameIdAll" \
            )
            ;;
        images-name)
            echo $( \
                ${_DOCKER-} images \
                | tail -n +2 \
                | grep -v '<none>' \
                | sed -e "$_regexGetDockerImageName" \
            )
            ;;
        dockerfile-and-images-name)
            cat \
                <( ${_RECKER_ABS-} _comp dockerfiles ) \
                <( ${_RECKER_ABS-} _comp images-name | sed -e 's|[[:blank:]]\{1,\}|\n|g' )
            ;;
        *)
            _die "Unknown action: ${_action-}"
            ;;
    esac
}

###
### command parsing
###

_candidates=''
IFS='|' eval '_candidates="${_SUB_COMMANDS[*]}"'
_subCommand="${1-}"
shift || :

if [[ "${_subCommand-}" =~ ^($_candidates)$ ]]; then
    :
elif [[ -n "${_subCommand-}" ]]; then
    _mention "Calling docker with: $_subCommand"
    ${_DOCKER-} ${_subCommand-} $@
    exit $?
fi

if type -t _recker-$_subCommand | grep -q function; then
    _recker-$_subCommand $@ \
        || exit "$?"
    exit 0
fi

if [[ "${_subCommand-}" ]]; then
    _warn "[Error] Unknown subcommand: ${_subCommand-}"
else
    _warn "[Error] Please specify subcommand"
fi
_showUsage
exit 1
